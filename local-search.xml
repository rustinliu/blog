<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTP各协议版本的区别</title>
    <link href="/2022/03/17/http%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/03/17/http%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="一、HTTP1-0"><a href="#一、HTTP1-0" class="headerlink" title="一、HTTP1.0"></a>一、HTTP1.0</h2><p><code>HTTP</code>协议的第二个版本，第一个在通讯中指定版本号的 HTTP 协议版本</p><p><code>HTTP 1.0</code> 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接</p><p>服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求</p><p>简单来讲，每次与服务器交互，都需要新开一个连接</p><p><img src="https://static.vue-js.com/efff4da0-b93a-11eb-85f6-6fac77c0c9b3.png"></p><p>例如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接</p><p>最终导致，一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接</p><p>这种形式明显造成了性能上的缺陷</p><p>如果需要建立长连接，需要设置一个非标准的 Connection 字段 <code>Connection: keep-alive</code></p><h2 id="二、HTTP1-1"><a href="#二、HTTP1-1" class="headerlink" title="二、HTTP1.1"></a>二、HTTP1.1</h2><p>在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个 TCP 连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟</p><p>建立一次连接，多次请求均由这个连接完成</p><p><img src="https://static.vue-js.com/22db2b90-b93b-11eb-ab90-d9ae814b240d.png"></p><p>这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输</p><p>同时，<code>HTTP 1.1</code>还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间</p><p>同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善的功能，如下：</p><ul><li>引入了更多的缓存控制策略，如 If-Unmodified-Since, If-Match, If-None-Match 等缓存头来控制缓存策略</li><li>引入 range，允许值请求资源某个部分</li><li>引入 host，实现了在一台 WEB 服务器上可以在同一个 IP 地址和端口号上使用不同的主机名来创建多个虚拟 WEB 站点</li></ul><p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code>…</p><h2 id="三、HTTP2-0"><a href="#三、HTTP2-0" class="headerlink" title="三、HTTP2.0"></a>三、HTTP2.0</h2><p>而<code>HTTP2.0</code>在相比之前版本，性能上有很大的提升，如添加了一个特性：</p><ul><li>多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ul><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><code>HTTP/2</code> 复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以<strong>同时</strong>发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</p><p><img src="https://static.vue-js.com/313f1980-b93b-11eb-85f6-6fac77c0c9b3.png"></p><p>上图中，可以看到第四步中<code>css</code>、<code>js</code>资源是同时发送到服务端</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>帧是<code>HTTP2</code>通信中最小单位信息</p><p><code>HTTP/2</code> 采用二进制格式传输数据，而非 <code>HTTP 1.x </code>的文本格式，解析起来更高效</p><p>将请求和响应数据分割为更小的帧，并且它们采用二进制编码</p><p><code>HTTP2 </code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流</p><p>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件</p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p><code>HTTP/2</code>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p><p>首部表在<code>HTTP/2</code>的连接存续期内始终存在，由客户端和服务器共同渐进地更新</p><p>例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销</p><p><img src="https://static.vue-js.com/3c536740-b93b-11eb-ab90-d9ae814b240d.png"></p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p><code>HTTP2</code>引入服务器推送，允许服务端推送资源给客户端</p><p>服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源</p><p>免得客户端再次创建连接发送请求到服务器端获取</p><p>这种方式非常合适加载静态资源</p><p><img src="https://static.vue-js.com/47130550-b93b-11eb-85f6-6fac77c0c9b3.png"></p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>HTTP1.0：</p><ul><li>浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接</li></ul><p>HTTP1.1：</p><ul><li>引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用</li><li>在同一个 TCP 连接里面，客户端可以同时发送多个请求</li><li>虽然允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着</li><li>新增了一些请求方法</li><li>新增了一些请求头和响应头</li></ul><p>HTTP2.0：</p><ul><li>采用二进制格式而非文本格式</li><li>完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</li><li>使用报头压缩，降低开销</li><li>服务器推送</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#HTTP/1.0">https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#HTTP/1.0</a></li><li><a href="https://www.jianshu.com/p/52d86558ca57">https://www.jianshu.com/p/52d86558ca57</a></li><li><a href="https://segmentfault.com/a/1190000016496448">https://segmentfault.com/a/1190000016496448</a></li><li><a href="https://zhuanlan.zhihu.com/p/26559480">https://zhuanlan.zhihu.com/p/26559480</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>元素水平垂直居中的解决方法</title>
    <link href="/2022/03/17/%E5%B1%85%E4%B8%AD%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/17/%E5%B1%85%E4%B8%AD%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>居中是一个非常基础但又是非常重要的应用场景，实现居中的方法存在很多，可以将这些方法分成两个大类：</p><ul><li>居中元素（子元素）的宽高已知</li><li>居中元素宽高未知</li></ul><h2 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h2><p>实现元素水平垂直居中的方式：</p><ul><li><p>利用定位+margin:auto</p></li><li><p>利用定位+margin:负值</p></li><li><p>利用定位+transform</p></li><li><p>table 布局</p></li><li><p>flex 布局</p></li><li><p>grid 布局</p></li></ul><h3 id="利用定位-margin-auto"><a href="#利用定位-margin-auto" class="headerlink" title="利用定位+margin:auto"></a>利用定位+margin:auto</h3><p>先上代码：</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.father</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#0a3b98</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.son</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#f0a238</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父级设置为相对定位，子级绝对定位 ，并且四个定位属性的值都设置了 0，那么这时候如果子级没有设置宽高，则会被拉开到和父级一样宽高</p><p>这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个<code>margin：auto</code>它就可以上下左右都居中了</p><h3 id="利用定位-margin-负值"><a href="#利用定位-margin-负值" class="headerlink" title="利用定位+margin:负值"></a>利用定位+margin:负值</h3><p>绝大多数情况下，设置父元素为相对定位， 子元素移动自身 50%实现水平垂直居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.father</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: skyblue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.son</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>整个实现思路如下图所示：</p><p><img src="https://static.vue-js.com/922dc300-95f9-11eb-ab90-d9ae814b240d.png"></p><ul><li>初始位置为方块 1 的位置</li><li>当设置 left、top 为 50%的时候，内部子元素为方块 2 的位置</li><li>设置 margin 为负数时，使内部子元素到方块 3 的位置，即中间位置</li></ul><p>这种方案不要求父元素的高度，也就是即使父元素的高度变化了，仍然可以保持在父元素的垂直居中位置，水平方向上是一样的操作</p><p>但是该方案需要知道子元素自身的宽高，但是我们可以通过下面<code>transform</code>属性进行移动</p><h3 id="利用定位-transform"><a href="#利用定位-transform" class="headerlink" title="利用定位+transform"></a>利用定位+transform</h3><p>实现代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.father</span> &#123;<br>        <span class="hljs-attribute">position</span>: relative;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>        <span class="hljs-attribute">background</span>: skyblue;<br>    &#125;<br>    <span class="hljs-selector-class">.son</span> &#123;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>        <span class="hljs-attribute">background</span>: red;<br>    &#125;<br>&lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;father&quot;&gt;<br>    &lt;<span class="hljs-selector-tag">div</span> class=&quot;son&quot;&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p><code>translate(-50%, -50%)</code>将会将元素位移自己宽度和高度的-50%</p><p>这种方法其实和最上面被否定掉的 margin 负值用法一样，可以说是<code>margin</code>负值的替代方案，并不需要知道自身元素的宽高</p><h3 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h3><p>设置父元素为<code>display:table-cell</code>，子元素设置 <code>display: inline-block</code>。利用<code>vertical</code>和<code>text-align</code>可以让所有的行内块级元素水平垂直居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.father</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: table-cell;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: skyblue;</span><br><span class="language-css">        <span class="hljs-attribute">vertical-align</span>: middle;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.son</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="flex-弹性布局"><a href="#flex-弹性布局" class="headerlink" title="flex 弹性布局"></a>flex 弹性布局</h3><p>还是看看实现的整体代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.father</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">align-items</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: skyblue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.son</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>css3</code>中了<code>flex</code>布局，可以非常简单实现垂直水平居中</p><p>这里可以简单看看<code>flex</code>布局的关键属性作用：</p><ul><li><p>display: flex 时，表示该容器内部的元素将按照 flex 进行布局</p></li><li><p>align-items: center 表示这些元素将相对于本容器水平居中</p></li><li><p>justify-content: center 也是同样的道理垂直居中</p></li></ul><h3 id="grid-网格布局"><a href="#grid-网格布局" class="headerlink" title="grid 网格布局"></a>grid 网格布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.father</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: grid;</span><br><span class="language-css">        <span class="hljs-attribute">align-items</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background</span>: skyblue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.son</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里看到，<code>gird</code>网格布局和<code>flex</code>弹性布局都简单粗暴</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有：</p><ul><li><p>利用定位+margin:auto</p></li><li><p>利用定位+transform</p></li><li><p>利用定位+margin:负值</p></li><li><p>flex 布局</p></li><li><p>grid 布局</p></li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>根据元素标签的性质，可以分为：</p><ul><li>内联元素居中布局</li><li>块级元素居中布局</li></ul><h3 id="内联元素居中布局"><a href="#内联元素居中布局" class="headerlink" title="内联元素居中布局"></a>内联元素居中布局</h3><p>水平居中</p><ul><li>行内元素可设置：text-align: center</li><li>flex 布局设置父元素：display: flex; justify-content: center</li></ul><p>垂直居中</p><ul><li>单行文本父元素确认高度：height &#x3D;&#x3D;&#x3D; line-height</li><li>多行文本父元素确认高度：disaply: table-cell; vertical-align: middle</li></ul><h3 id="块级元素居中布局"><a href="#块级元素居中布局" class="headerlink" title="块级元素居中布局"></a>块级元素居中布局</h3><p>水平居中</p><ul><li>定宽: margin: 0 auto</li><li>绝对定位+left:50%+margin:负自身一半</li></ul><p>垂直居中</p><ul><li>position: absolute 设置 left、top、margin-left、margin-top(定高)</li><li>display: table-cell</li><li>transform: translate(x, y)</li><li>flex(不定高，不定宽)</li><li>grid(不定高，不定宽)，兼容性相对比较差</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://juejin.cn/post/6844903982960214029#heading-10">https://juejin.cn/post/6844903982960214029#heading-10</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中实现深拷贝的几个方法</title>
    <link href="/2022/03/13/JavaScript%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/13/JavaScript%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> b = <span class="hljs-title class_">JSON</span>.<span class="hljs-property">parse</span> ( <span class="hljs-title class_">JSON</span>.<span class="hljs-property">stringify</span> (a ) );<br></code></pre></td></tr></table></figure><p>优点：简单</p><p>缺点：</p><ol><li>JSON 只有六种数据格式，所以在转化时不支持 Date、正则、undefined、函数等数据</li><li>. 不支持引用(即环状结构)</li></ol><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">deepClone</span> = (<span class="hljs-params">a, cache</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!cache) &#123;<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>        <span class="hljs-comment">// 缓存不能全局，最好临时创建并递归传递</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;<br>        <span class="hljs-comment">// 不考虑跨iframe</span><br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">get</span>(a)) &#123;<br>            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(a);<br>        &#125;<br>        <span class="hljs-keyword">let</span> result;<br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>) &#123;<br>            <span class="hljs-keyword">if</span> (a.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) &#123;<br>                <span class="hljs-comment">// 有 prototype 就是普通函数</span><br>                result = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>                &#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 没有 prototype 就是箭头函数</span><br>                result = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, ...args);<br>                &#125;;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;<br>            result = [];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) &#123;<br>            result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(a - <span class="hljs-number">0</span>); <span class="hljs-comment">//a-0是为了转换成数字，变成时间戳</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) &#123;<br>            result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(a.<span class="hljs-property">source</span>, a.<span class="hljs-property">flags</span>); <span class="hljs-comment">// 正则</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = &#123;&#125;;<br>        &#125;<br>        cache.<span class="hljs-title function_">set</span>(a, result);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> a) &#123;<br>            <span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>                result[key] = <span class="hljs-title function_">deepClone</span>(a[key], cache);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要点如下：</p><ul><li>递归的使用</li><li>判断类型</li><li>检查环（使用 Map 实现）</li><li>不拷贝原型上的属性（使用 <code>hasOwnProperty</code>方法来实现）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于HTTPS的一些知识点</title>
    <link href="/2022/03/13/https/"/>
    <url>/2022/03/13/https/</url>
    
    <content type="html"><![CDATA[<h2 id="需要对密码学简单认识一下"><a href="#需要对密码学简单认识一下" class="headerlink" title="需要对密码学简单认识一下"></a>需要对密码学简单认识一下</h2><p>什么是对称加密、非对称加密、单向散列、消息认证码、数字签名、证书、PKI 体系</p><p><strong>信息安全</strong></p><ul><li>机密性：信息是否被泄漏。使用对称加密、非对称加密来保证</li><li>完整性：信息是否被修改，使用单向散列、消息认证码、数字签名来保证</li><li>真实性：发送者是否冒名顶替的。使用消息认证码、数字签名来保证</li><li>不可否认性：做过了会不会抵赖。使用数字签名来保证</li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p><strong>实现信息安全的机密性，那么可以使用对称加密</strong></p><p><strong>什么是对称加密：</strong></p><ul><li>使用同一个密钥进行加密解密，算法速度快。</li><li>对称加密常见的算法是 DES 和 AES。</li><li>对称加密算法常用来加密大量内容。</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78083874b76d4995b0d277bb293eb1c0~tplv-k3u1fbpfcp-watermark.image" alt="对称加密.png"></p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p><strong>实现信息安全的机密性，那么可以使用非对称加密</strong></p><p><strong>什么是非对称加密：</strong></p><ul><li>拥有俩个密钥：公钥和私钥，公钥公开的给别人，私钥自己保存着。</li><li>公钥加密后的密文可以使用私钥来解密</li><li>私钥加密后的密文可以使用公钥来解密</li><li>对比与 对称加密要慢上许多</li><li>常见的非对称算法是 RSA</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41f50a747b3e4fc1a5c50cfb08819dda~tplv-k3u1fbpfcp-watermark.image" alt="非对称加密.png"></p><p>使用非对称加密算法可以直接加密信息。比如小明生成自己的密钥时，把公钥对外公开。小红想向小明传输信息可使用小明的公钥对消息加密后再发送，然后小明收到后可以用自己的私钥来解密。其他人即时得到加密后的信息也无法破解。</p><p><strong>不过这样使用开销很大，一般现实中使用对称加密来加密原始消息，使用非对称加密来传输用来加密消息的对称密钥，（用非对称加密来加密对称加密的密钥。）</strong></p><h3 id="单向散列（hash）"><a href="#单向散列（hash）" class="headerlink" title="单向散列（hash）"></a>单向散列（hash）</h3><p><strong>可以用单向散列来证明数据的完整性</strong></p><p>不定长的数经散发处理后会压缩成固定长度。其特点是相同的输入一定有相同的输出，不同的输入几乎没有相同的输出，根据输出无法还原输入。</p><p>场景举例：我们再网站上对外公布了一个 10Gb 大小的资源链接和对应的 sha256 哈希值。用户从第三方下载到类似资源后可以做 sha256 散列运算，如果计算的哈希值和我们原始资源的哈希值相同，就表示数据是真实完整的</p><p>常见的散列算法有：MD5(<strong>不安全</strong>)、SHA1、SHA256</p><h3 id="消息认证码（hmac）"><a href="#消息认证码（hmac）" class="headerlink" title="消息认证码（hmac）"></a>消息认证码（hmac）</h3><p><strong>消息认证码就是带密钥的散列函数</strong></p><p><strong>特点：</strong></p><ol><li>大量信息经过处理变成短小固定长度值（有点类似单向散列）</li><li>消息不同或者密钥不同会导致结果不同</li><li>无法从结果“解密”出原始信息</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c467eedef60d4d0c9514e4c39888126e~tplv-k3u1fbpfcp-watermark.image" alt="消息认证码.png"></p><p><strong>toekn &#x3D; header（算法名）+ ‘.’ + payload(有用信息) + ‘.’ + hmac(header + ‘.’ + patload,密钥)</strong></p><p>使用场景:JWT 鉴权使用的 token 就用到了消息认证码。当服务器把 token 发送给客户端，客户端下次请求时要带上 token，服务器收到 token 后会截取 header + ‘.’ + payload 做 hmac 运算，得到的结果和 token 的第三部分即 hmac 做对比。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>小明使用私钥对消息加密即<strong>签名</strong>，其他人使用小明的公钥如果能解密表示消息一定是小明发的。</p><p><strong>签名能防止抵赖的发生，用来保证信息的不可否认性</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8f7d6aa8131464f91b8f9f30e0f4132~tplv-k3u1fbpfcp-watermark.image" alt="数字签名.png"></p><h3 id="证书与-PKI-体系"><a href="#证书与-PKI-体系" class="headerlink" title="证书与 PKI 体系"></a>证书与 PKI 体系</h3><p>一个证书上包含一些公开的明文信息以及证书颁发者对该信息的签名(私钥加密)。任何人想验证证书信息的真伪，只需要用证书颁发者的公钥对签名进行解密，再和证书上的明文信息做对比即可。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b882f0b46cb49c3b3b7af869881d2b5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="HTTPS-是如何做密钥协商的"><a href="#HTTPS-是如何做密钥协商的" class="headerlink" title="HTTPS 是如何做密钥协商的"></a>HTTPS 是如何做密钥协商的</h2><h3 id="什么是-HTTPS"><a href="#什么是-HTTPS" class="headerlink" title="什么是 HTTPS"></a>什么是 HTTPS</h3><p>HTTPS 是超文本传输安全协议,在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。</p><p><strong>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</strong></p><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ul><li>HTTP 不需要认证，而 HTTPS 需要认证</li><li>一般来说 HTTP 速度会比 HTTPS 更快</li><li>HTTP 使用 80 端口 ， HTTPS 使用 443 端口。</li><li>HTTP 数据传是明文传输，不安全。 HTTPS 数据加密了，可保证数据私密性、完整性、防止中间人攻击。</li></ul><h3 id="SSL-x2F-TLS-协议流程（HTTPS-握手过程）"><a href="#SSL-x2F-TLS-协议流程（HTTPS-握手过程）" class="headerlink" title="SSL&#x2F;TLS 协议流程（HTTPS 握手过程）"></a>SSL&#x2F;TLS 协议流程（HTTPS 握手过程）</h3><p><strong>详细流程：</strong></p><ol><li>浏览器将自己支持的一套加密算法发给服务器，同时发一个浏览器随机数</li><li>服务器向浏览器发送选择的加密算法、服务器生成的随机数、服务器数字证书</li><li>浏览器收到证书后对证书的 CA 签名进行验证，如果验证通过，会从证书中拿到服务器的公钥。</li><li>浏览器对浏览器随机数+服务器随机数进行处理，生成预备主密码。</li><li>浏览器使用服务器的公钥对预备主密码进行加密，发给服务器。</li><li>服务器收到后使用自己的私钥解密出预备主密钥。</li><li>浏览器和服务器分别使用预备主密钥和俩个随机数，生成共享主密钥。</li><li>二者使用共享主密钥，使用对称加密算法加密数据。</li></ol><p><strong>简单的来说：</strong></p><ol><li>浏览器使用 HTTPS 的 url 访问服务器与服务器建立 SSL 连接。</li><li>服务器收到请求行，会发送包含公钥的证书</li><li>浏览器使用公钥加密对称密钥并发送给服务器</li><li>服务器使用私钥解密对称密钥</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Ajax</title>
    <link href="/2022/03/13/%E6%89%8B%E5%86%99Ajax/"/>
    <url>/2022/03/13/%E6%89%8B%E5%86%99Ajax/</url>
    
    <content type="html"><![CDATA[<p>代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">const ajax =<span class="hljs-function"> (<span class="hljs-params">method</span>, <span class="hljs-params">url</span>, <span class="hljs-params">data</span>, <span class="hljs-params">success</span>, <span class="hljs-params">fail</span>) =&gt;</span> &#123;<br>    var request = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLHttpRequest()</span>;<br>    request.<span class="hljs-keyword">open</span>(<span class="hljs-keyword">method</span>, url); <span class="hljs-comment">//这里默认用异步请求</span><br>    request.onreadystatechange = <span class="hljs-keyword">function</span> <span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (request.readyState<span class="hljs-operator"> === </span><span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((request.status &gt;= <span class="hljs-number">200</span><span class="hljs-operator"> &amp;&amp; </span>request.status &lt; <span class="hljs-number">300</span>)<span class="hljs-operator"> || </span>request.status<span class="hljs-operator"> === </span><span class="hljs-number">304</span>) &#123;<br>                success(request);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                fail(request);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    request.send<span class="hljs-literal">()</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Ajax</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise</title>
    <link href="/2022/03/13/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88promise/"/>
    <url>/2022/03/13/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%89%88promise/</url>
    
    <content type="html"><![CDATA[<h3 id="简易-Promise-实现"><a href="#简易-Promise-实现" class="headerlink" title="简易 Promise 实现"></a>简易 Promise 实现</h3><p>简易的原因是只有一次 <code>then()</code>，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise2</span> &#123;<br>    #status = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">q</span> = [];<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>            <span class="hljs-variable language_">this</span>.#status = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>            <span class="hljs-keyword">const</span> f1f2 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">q</span>.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span> (!f1f2 || !f1f2[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">const</span> x = f1f2[<span class="hljs-number">0</span>].<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, data);<br>            <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise2</span>) &#123;<br>                x.<span class="hljs-title function_">then</span>(<br>                    <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                        <span class="hljs-title function_">resolve</span>(data);<br>                    &#125;,<br>                    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>                        <span class="hljs-title function_">reject</span>(reason);<br>                    &#125;<br>                );<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(x);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>            <span class="hljs-variable language_">this</span>.#status = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>            <span class="hljs-keyword">const</span> f1f2 = <span class="hljs-variable language_">this</span>.<span class="hljs-property">q</span>.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span> (!f1f2 || !f1f2[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">const</span> x = f1f2[<span class="hljs-number">1</span>].<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, reason);<br>            <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise2</span>) &#123;<br>                x.<span class="hljs-title function_">then</span>(<br>                    <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                        <span class="hljs-title function_">resolve</span>(data);<br>                    &#125;,<br>                    <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>                        <span class="hljs-title function_">reject</span>(reason);<br>                    &#125;<br>                );<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(x);<br>            &#125;<br>        &#125;;<br>        fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, resolve, reject);<br>    &#125;<br>    <span class="hljs-title function_">then</span>(<span class="hljs-params">f1, f2</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">q</span>.<span class="hljs-title function_">push</span>([f1, f2]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise2</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;出错&#x27;</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br>p.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(r);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p>详细可看：<a href="https://zhuanlan.zhihu.com/p/183801144">面试官：“你能手写一个 Promise 吗” - 知乎 (zhihu.com)</a></p><h3 id="手写-Promise-all"><a href="#手写-Promise-all" class="headerlink" title="手写 Promise.all"></a>手写 Promise.all</h3><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myAll</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">promiseList</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> resultList = [];<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>        promiseList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>            promise.<span class="hljs-title function_">resolve</span>(<br>                <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>                    resultList[index] = result;<br>                    count += <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (count === promiseList.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-title function_">resolve</span>(resultList);<br>                    &#125;<br>                &#125;,<br>                <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>                    <span class="hljs-title function_">reject</span>(reason);<br>                &#125;<br>            );<br>        &#125;);<br>    &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>要点如下：</p><ul><li>了解 all 的参数和返回值</li><li>用数组来记录结果</li><li>只要有一个 reject 就整体 reject</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>手写</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写节流防抖函数</title>
    <link href="/2022/03/13/%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <url>/2022/03/13/%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<p>因为整体并不复杂，直接上代码理解就可以了。</p><h3 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 节流就是「技能冷却中」</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle1</span> = (<span class="hljs-params">fn, time</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;<br>        fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, ...args);<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125;, time);<br>    &#125;;<br>&#125;;<br><span class="hljs-comment">// 还有一个版本是 在冷却结束时调用 fn</span><br><span class="hljs-comment">// 简洁版，删掉冷却中变量，直接使用 timer 代替</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">throttle2</span> = (<span class="hljs-params">fn, time</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (timer) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, ...args);<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;, time);<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 防抖就是「回城被打断」</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">debounce</span> = (<span class="hljs-params">fn, time</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (timer !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">clearTimeout</span>(timer); <span class="hljs-comment">// 打断回城</span><br>        &#125;<br>        <span class="hljs-comment">// 重新回城</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, ...args); <span class="hljs-comment">// 回城后调用 fn</span><br>            timer = <span class="hljs-literal">null</span>;<br>        &#125;, time);<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写订阅与发布模式</title>
    <link href="/2022/03/13/%E6%89%8B%E5%86%99%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/13/%E6%89%8B%E5%86%99%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="对象方式"><a href="#对象方式" class="headerlink" title="对象方式"></a>对象方式</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> eventHub = &#123;<br>    <span class="hljs-attr">map</span>: &#123;<br>        <span class="hljs-comment">//haspMap</span><br>        <span class="hljs-comment">// click: [f1 , f2]</span><br>    &#125;,<br>    <span class="hljs-attr">on</span>: <span class="hljs-function">(<span class="hljs-params">name, fn</span>) =&gt;</span> &#123;<br>        eventHub.<span class="hljs-property">map</span>[name] = eventHub.<span class="hljs-property">map</span>[name] || []; <span class="hljs-comment">//设计模式：防御性编程，避免eventHub.map[name]不存在</span><br>        eventHub.<span class="hljs-property">map</span>[name].<span class="hljs-title function_">push</span>(fn);<br>    &#125;,<br>    <span class="hljs-attr">emit</span>: <span class="hljs-function">(<span class="hljs-params">name, data</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> q = eventHub.<span class="hljs-property">map</span>[name]; <span class="hljs-comment">//设计模式：Alias 别名</span><br>        <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">return</span>;<br>        q.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">f</span>) =&gt;</span> f.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, data));<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>    &#125;,<br>    <span class="hljs-attr">off</span>: <span class="hljs-function">(<span class="hljs-params">name, fn</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> q = eventHub.<span class="hljs-property">map</span>[name]; <span class="hljs-comment">//设计模式：Alias 别名</span><br>        <span class="hljs-keyword">if</span> (!q) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> index = q.<span class="hljs-title function_">indexOf</span>(fn);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        q.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">eventHub.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<br>eventHub.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    eventHub.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;frank&#x27;</span>);<br>&#125;, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><h3 id="class-方式"><a href="#class-方式" class="headerlink" title="class 方式"></a>class 方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventHub</span> &#123;<br>    map = &#123;&#125;;<br>    <span class="hljs-title function_">on</span>(<span class="hljs-params">name, fn</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[name] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[name] || [];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[name].<span class="hljs-title function_">push</span>(fn);<br>    &#125;<br>    <span class="hljs-title function_">emit</span>(<span class="hljs-params">name, data</span>) &#123;<br>        <span class="hljs-keyword">const</span> fnList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[name] || [];<br>        fnList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, data));<br>    &#125;<br>    <span class="hljs-title function_">off</span>(<span class="hljs-params">name, fn</span>) &#123;<br>        <span class="hljs-keyword">const</span> fnList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[name] || [];<br>        <span class="hljs-keyword">const</span> index = fnList.<span class="hljs-title function_">indexOf</span>(fn);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> fnList.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使 用 const e = new EventHub()</span><br><br>e.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi &#x27;</span> + name);<br>&#125;);<br>e.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello &#x27;</span> + name);<br>&#125;);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    e.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;frank&#x27;</span>);<br>&#125;, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习总结之泛型</title>
    <link href="/2022/01/06/TypeScript%E7%AC%94%E8%AE%B05/"/>
    <url>/2022/01/06/TypeScript%E7%AC%94%E8%AE%B05/</url>
    
    <content type="html"><![CDATA[<p>​</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在像 C#和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// T : 泛型变量 | 类型变量</span><br><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><span class="hljs-title function_">identity</span>(<span class="hljs-number">123</span>);<br><span class="hljs-title function_">identity</span>(<span class="hljs-string">&#x27;123&#x27;</span>);<br></code></pre></td></tr></table></figure><p>代码中 <strong>T 代表 「Type」</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。</p><p>由于我们操作的是数组，所以.length 属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> loggingIdentity&lt;T&gt;(<span class="hljs-attr">arg</span>: T[]): T[] &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>); <span class="hljs-comment">// Array has a .length, so no more error</span><br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> identity&lt;T, U&gt;(<span class="hljs-attr">value</span>: T, <span class="hljs-attr">message</span>: U): T &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">identity</span>(<span class="hljs-number">666</span>, <span class="hljs-string">&#x27;jack is cool!&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="泛型类型-amp-amp-泛型接口"><a href="#泛型类型-amp-amp-泛型接口" class="headerlink" title="泛型类型 &amp;&amp; 泛型接口"></a>泛型类型 &amp;&amp; 泛型接口</h2><p>泛型类型不同的注解方式:</p><ol><li>函数泛型的注解方式</li><li>对象字面量的方式来定义泛型类型</li><li>泛型接口的定义方式</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//  泛型类型的不同方式</span><br><span class="hljs-keyword">function</span> identity&lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-comment">// 1. 函数泛型的注解方式：</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">arg: T</span>) =&gt;</span> T = identity;<br><br><span class="hljs-comment">// 2. 对象字面量的方式来定义泛型类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: &#123; &lt;T&gt;(<span class="hljs-attr">arg</span>: T): T &#125; = identity;<br><br><span class="hljs-comment">// 3. 泛型接口的定义方式</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IdentityInterface</span> &#123;<br>    &lt;T&gt;(<span class="hljs-attr">arg</span>: T): T;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span>: <span class="hljs-title class_">IdentityInterface</span> = identity;<br></code></pre></td></tr></table></figure><h2 id="泛型类-amp-泛型约束"><a href="#泛型类-amp-泛型约束" class="headerlink" title="泛型类 &amp; 泛型约束"></a>泛型类 &amp; 泛型约束</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类看上去与泛型接口差不多，我们只需要在类名后面，使用 &lt;T, …&gt; 的语法定义任意多个类型变量，具体示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">list</span>: T[] = [];<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">num: T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(num);<br>    &#125;<br>    <span class="hljs-title function_">min</span>(): T &#123;<br>        <span class="hljs-keyword">let</span> minNum = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (minNum &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[i]) &#123;<br>                minNum = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在什么时候需要使用泛型呢？通常在决定是否使用泛型时，我们有以下两个参考标准：</p><ul><li>当你的函数、接口或类将处理多种数据类型时；</li><li>当函数、接口或类在多个地方使用该数据类型时。</li></ul><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>有时我们可能希望限制每个类型变量接受的类型数量，这就是泛型约束的作用。</strong></p><p>以官方文档例子为例：</p><p>我们需要去定义一个接口来描述约束条件。</p><p>创建一个包含 .length 属性的接口，使用这个接口和 extends 关键字来实现约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LengthInterface</span> &#123;<br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LengthInterface</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中,<strong>泛型约束用的是： extends 继承接口的方式（不一定非要是接口）</strong> 、<code>T extends LengthInterface </code>用于告诉编译器，我们支持已经实现 Length 接口的任何类型</p><p>另外， 泛型约束并不一定用接口方式， 比如 我们可以把以上代码 接口 换成 类型别名 ,<br>如下例子：<br>&#x2F;&#x2F; 以类型别名的方式依然可以</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">LengthType</span> = <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">function</span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LengthType</span>&gt;(<span class="hljs-attr">arg</span>: T): T &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="keyof-操作符"><a href="#keyof-操作符" class="headerlink" title="keyof 操作符"></a>keyof 操作符</h4><p><strong>keyof 操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// keyof 操作符</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">location</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K1</span> = keyof <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// &quot;name&quot; | &quot;age&quot; | &quot;location&quot;</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K2</span> = keyof <span class="hljs-title class_">Person</span>[]; <span class="hljs-comment">// number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">K3</span> = keyof &#123; [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Person</span> &#125;; <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><p>可以看出， k1,k2,k3 其实是键名</p><h4 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h4><p>当我们理解了 keyof 操作符时， 看下面代码就很好理解了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> getProperty&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: K) &#123;<br>    <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br><br><span class="hljs-keyword">let</span> x = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> &#125;;<br><br><span class="hljs-title function_">getProperty</span>(x, <span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// okay</span><br><span class="hljs-title function_">getProperty</span>(x, <span class="hljs-string">&#x27;m&#x27;</span>); <span class="hljs-comment">// error: Argument of type &#x27;m&#x27; isn&#x27;t assignable to &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; | &#x27;d&#x27;.</span><br></code></pre></td></tr></table></figure><p>**而 K 就是指 ‘a’ , ‘b’ , ‘c’ , ‘d’ **</p><p>很明显通过使用泛型约束，在编译阶段我们就可以提前发现错误，大大提高了程序的健壮性和稳定性。</p><h3 id="多重泛型约束-amp-交叉类型"><a href="#多重泛型约束-amp-交叉类型" class="headerlink" title="多重泛型约束 &amp; 交叉类型"></a>多重泛型约束 &amp; 交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> extend&lt;T, U&gt;(<span class="hljs-attr">first</span>: T, <span class="hljs-attr">second</span>: U): T &amp; U &#123;<br>    <span class="hljs-keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;; // 断言， 表示 result 包含 T  U 俩种类型<br>    for (let id in first) &#123;<br>        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; // 将 first 中所有属性 给 result<br>    &#125;<br>    for (let id in second) &#123;<br>        if (!result.hasOwnProperty(id)) &#123;<br>            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];<br>            // 将 second 中所有属性 给 result, 前提是result 没有该属性时<br>        &#125;<br>    &#125;<br>    return result; // 返回的 result 就有  first 和 second 的所有属性<br>&#125;<br><br>class Person &#123;<br>    constructor(public name: string) &#123;&#125;<br>&#125;<br>interface Loggable &#123;<br>    log(): void;<br>&#125;<br>class ConsoleLogger implements Loggable &#123;<br>    log() &#123;<br>        // ...<br>    &#125;<br>&#125;<br>var jim = extend(new Person(&#x27;Jim&#x27;), new ConsoleLogger());<br>var n = jim.name;<br>jim.log();<br></code></pre></td></tr></table></figure><p>再举个简单例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sentence</span> &#123;<br>    <span class="hljs-attr">content</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Music</span> &#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sentence</span> &amp; <span class="hljs-title class_">Music</span>&gt; &#123;<br>    <span class="hljs-attr">props</span>: T;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> arg: T</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = arg;<br>    &#125;<br><br>    <span class="hljs-title function_">info</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-comment">// 这里可以 this.props.xxx 的原因是因为 arg 符合 T类型， 而T 又继承了上面俩个接口的属性。</span><br>            <span class="hljs-attr">content</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">content</span>,<br>            <span class="hljs-attr">title</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">title</span>,<br>            <span class="hljs-attr">url</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">url</span>,<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型中的类类型"><a href="#泛型中的类类型" class="headerlink" title="泛型中的类类型"></a>泛型中的类类型</h3><p><strong>泛型中的类类型 目的是 约束或者更好的推论</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeeKeeper</span> &#123;<br>    <span class="hljs-attr">hasMask</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooKeeper</span> &#123;<br>    <span class="hljs-attr">nametag</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-attr">numLegs</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-attr">keeper</span>: <span class="hljs-title class_">BeeKeeper</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-attr">keeper</span>: <span class="hljs-title class_">ZooKeeper</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> createInstance&lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt;(<span class="hljs-attr">c</span>: <span class="hljs-keyword">new</span> () =&gt; A): A &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">c</span>();<br>&#125;<br><br><span class="hljs-title function_">createInstance</span>(<span class="hljs-title class_">Lion</span>).<span class="hljs-property">keeper</span>.<span class="hljs-property">nametag</span>; <span class="hljs-comment">// typechecks!</span><br><span class="hljs-title function_">createInstance</span>(<span class="hljs-title class_">Bee</span>).<span class="hljs-property">keeper</span>.<span class="hljs-property">hasMask</span>; <span class="hljs-comment">// typechecks!</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习总结之接口</title>
    <link href="/2022/01/05/TypeScript%E7%AC%94%E8%AE%B04/"/>
    <url>/2022/01/05/TypeScript%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<p>​</p><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h2><blockquote><p>在 TypeScript 学习总结之基础类型 那一章节中，我稍微学习了一下 接口 interface， 对它有了初步了解， 接下来总结的是 TS 文档接口这一章节。</p></blockquote><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>以官方文档代码为例， 我分析了几种函数注解的方式：</p><p><strong>方式一:</strong></p><p>（最常见的）</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;<br>    (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span>;<br>mySearch = <span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);<br>    <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方式二:</strong></p><p>&#x2F;&#x2F; 这种注解方式， 你会发现它同样把函数的实现方式也给实现了。 这样做不太好</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;<br>    (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-comment">// let mySearch: SearchFunc;</span><br><span class="hljs-comment">// mySearch = function (source: string, subString: string) &#123;</span><br><span class="hljs-comment">//   let result = source.search(subString);</span><br><span class="hljs-comment">//   return result &gt; -1;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySearch</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);<br>    <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式三：</strong></p><p>&#x2F;&#x2F; 通过 表达式的方式 你会发现 代码会显得特别长</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;<br>    (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-function">(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span><br><span class="hljs-params">    source: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">    subString: <span class="hljs-built_in">string</span></span><br><span class="hljs-params"></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);<br>    <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>方式四：</strong></p><p>把方式三 给抽离出来看看</p><ol><li>使用类型别名：</li><li>使用 接口 interface （这个和方式一 就一模一样了）)</li></ol><p>&#x2F;&#x2F; 1.类型别名 方式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 类型别名 方式</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">SearchFunc</span> = <span class="hljs-function">(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);<br>    <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 2.接口 interface 方式 （最常见的）</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 接口 interface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SearchFunc</span> &#123;<br>    (<span class="hljs-attr">source</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mySearch</span>: <span class="hljs-title class_">SearchFunc</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">let</span> result = source.<span class="hljs-title function_">search</span>(subString);<br>    <span class="hljs-keyword">return</span> result &gt; -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="可索引的类型-接口"><a href="#可索引的类型-接口" class="headerlink" title="可索引的类型 接口"></a>可索引的类型 接口</h3><blockquote><p>可索引的类型的接口 指的就是 数组类型的接口</p></blockquote><p>可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p><p>TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberArray</span> &#123;<br>    [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span>: <span class="hljs-title class_">NumberArray</span> = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 其实这个索引值 0 1 2 都是字符串 虽然定义的是数字， 但终究会转换成string</span><br>    <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span>: <span class="hljs-title class_">NumberArray</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>因为当使用 number 来索引时， JavaScript 终究会将它转换成 string 然后再去索引对象。</p><p><strong>由此可知：在索引签名中， string 是包含着 number 的</strong></p><p>再举个例子:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-attr">breed</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span><br><span class="hljs-comment">// interface NotOkay &#123;</span><br><span class="hljs-comment">//   [x: number]: Animal;</span><br><span class="hljs-comment">//   [x: string]: Dog;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// success</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NotOkay</span> &#123;<br>    [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-title class_">Animal</span>; <span class="hljs-comment">//因为Animal是父类，只能是string</span><br>    [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-title class_">Dog</span>; <span class="hljs-comment">// Dog继承了Animal 但索引又想和Animal一样，那么把它换成number即可</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>再看看 索引的返回值， 索引签名中 规定是什么类型就是什么类型，</p><p>因为 对象中 key 一定是字符串，但 value 不一定是</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberDictionary</span> &#123;<br>    [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可以，length是number类型</span><br>    <span class="hljs-comment">// name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类-类型接口"><a href="#类-类型接口" class="headerlink" title="类 类型接口"></a>类 类型接口</h3><blockquote><p>对 类 的一部分行为进行抽象；</p></blockquote><blockquote><p>类实现所有接口中的属性和方法 &amp;&amp; 对比 对象类： 抽象方法需要实现</p></blockquote><p>与 C#或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>; <span class="hljs-comment">// 定义属性</span><br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-attr">d</span>: <span class="hljs-title class_">Date</span>): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 定义方法</span><br>&#125;<br><span class="hljs-comment">// implements  实现   专门用来实现接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(); <span class="hljs-comment">// 实现实现</span><br>    <span class="hljs-title function_">setTime</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 实现方法</span><br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类继承+类类型接口 示例：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Alarm</span> &#123;<br>    <span class="hljs-comment">//  警告器</span><br>    <span class="hljs-title function_">alert</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Light</span> &#123;<br>    <span class="hljs-comment">//  车灯</span><br>    <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">lightOn</span>(): <span class="hljs-built_in">void</span>;<br>    <span class="hljs-title function_">lightOff</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Door</span> &#123;&#125;<br><span class="hljs-comment">// 继承 Door （门） 这个类  然后实现   Alarm  接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">securityDoor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Door</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Alarm</span> &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;咚咚咚&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// car 要实现 这个俩个接口的方法和属性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Alarm</span>, <span class="hljs-title class_">Light</span> &#123;<br>    color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-title function_">lightOn</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-title function_">lightOff</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>类是具有两个类型的：静态部分的类型和实例的类型</p><p>而 constructor 存在于类的静态部分， 所以不再检查的范围内</p><p>因此，类静态部分和实例部分需要单独分开来做</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定于一个  闹钟接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    <span class="hljs-attr">currentTime</span>: <span class="hljs-title class_">Date</span>;<br>    <span class="hljs-title function_">getTime</span>(<span class="hljs-attr">hour</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">mins</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>;<br>&#125;<br><span class="hljs-comment">// 定于一个  闹钟构造函数接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClockConstructor</span> &#123;<br>    <span class="hljs-keyword">new</span> (<span class="hljs-attr">hour</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">mins</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-comment">// Clock 去实现 闹钟接口ClockInterface</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClockInterface</span> &#123;<br>    currentTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-title function_">getTime</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个构造函数 createClock 通过构造函数检查构造函数的方式 去 new 一个C</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClock</span>(<span class="hljs-params">C: ClockConstructor, hour: <span class="hljs-built_in">number</span>, mins: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(hour, mins);<br>&#125;<br><br><span class="hljs-comment">// 实例化</span><br><span class="hljs-keyword">let</span> clock = <span class="hljs-title function_">createClock</span>(<span class="hljs-title class_">Clock</span>, <span class="hljs-number">12</span>, <span class="hljs-number">12</span>);<br></code></pre></td></tr></table></figure><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><p>因为 接口是对对象的形状进行描述； 所以接口可以继承接口，</p><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-attr">sideLength</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">// 类型断言</span><br><span class="hljs-comment">// let square = &lt;Square&gt;&#123;&#125;;</span><br><span class="hljs-keyword">let</span> square = &#123;&#125; <span class="hljs-keyword">as</span> <span class="hljs-title class_">Square</span>;<br>square.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;blue&#x27;</span>;<br>square.<span class="hljs-property">sideLength</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>函数类型的 interface ，添加属性的方式来实现 对象的 interface</p><p>相当于 函数类型的 interface + 对象类型的 interface</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Counter</span> &#123;<br>    (<span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 有点像构造函数</span><br>    <span class="hljs-attr">interval</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-title function_">reset</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getCounter</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">let</span> counter = &lt;<span class="hljs-title class_">Counter</span>&gt;<span class="hljs-keyword">function</span> (<span class="hljs-params">start: <span class="hljs-built_in">number</span></span>) &#123;&#125;; <span class="hljs-comment">// 断言   可以理解为 给 counter 初始值</span><br>    counter.<span class="hljs-property">interval</span> = <span class="hljs-number">123</span>;<br>    counter.<span class="hljs-property">reset</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-title function_">getCounter</span>();<br><span class="hljs-title function_">c</span>(<span class="hljs-number">10</span>);<br>c.<span class="hljs-title function_">reset</span>();<br>c.<span class="hljs-property">interval</span> = <span class="hljs-number">5.0</span>;<br></code></pre></td></tr></table></figure><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><ol><li>接口可以接触接口</li><li>接口可以继承类</li><li>类可以实现接口</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//   定义 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Control</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">state</span>: <span class="hljs-built_in">any</span>;<br>&#125;<br><br><span class="hljs-comment">//  接口继承类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelectableControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Control</span> &#123;<br>    <span class="hljs-title function_">select</span>(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-comment">//   类继承类然后实现接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Control</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SelectableControl</span> &#123;<br>    <span class="hljs-title function_">select</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">//  类继承接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Control</span> &#123;<br>    <span class="hljs-title function_">select</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 错误：“Image”类型缺少“state”属性。</span><br><span class="hljs-comment">// class Images implements SelectableControl &#123;</span><br><span class="hljs-comment">//   select() &#123; &#125;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>最后，看了俩遍文档还是有点迷。。。。。 以后多练习练习</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习总结之函数</title>
    <link href="/2022/01/03/TypeScript%E7%AC%94%E8%AE%B02/"/>
    <url>/2022/01/03/TypeScript%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<p>​</p><h2 id="函数的注解方式"><a href="#函数的注解方式" class="headerlink" title="函数的注解方式"></a>函数的注解方式</h2><h3 id="函数声明的注解方式"><a href="#函数声明的注解方式" class="headerlink" title="函数声明的注解方式"></a>函数声明的注解方式</h3><blockquote><p>注解 参数和返回值</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test1</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数表达式的注解方式"><a href="#函数表达式的注解方式" class="headerlink" title="函数表达式的注解方式"></a>函数表达式的注解方式</h3><p>&#x2F;&#x2F; 不用给 function 后边写注解， 因为会根据前边的注解来做类型推断</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">test</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">test1</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">test2</span>: <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">never</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + b);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p><strong>&#x2F;&#x2F; 默认：传递给一个函数的参数个数必须与函数期望的参数个数一致。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><br><span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// 少一个参数        // error, too few parameters</span><br><span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Adams&#x27;</span>, <span class="hljs-string">&#x27;Sr.&#x27;</span>); <span class="hljs-comment">// 多一个参数  // error, too many parameters</span><br><span class="hljs-keyword">let</span> result3 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Adams&#x27;</span>); <span class="hljs-comment">// ah, just right</span><br></code></pre></td></tr></table></figure><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p><strong>&#x2F;&#x2F; 注意：可选参数必须要放在必选参数的后边，否则会报错。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (lastName) <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> firstName;<br>&#125;<br><br><span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// is OK</span><br><span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Adams&#x27;</span>, <span class="hljs-string">&#x27;Sr.&#x27;</span>); <span class="hljs-comment">// 错误，多个一参数</span><br><span class="hljs-keyword">let</span> result3 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Adams&#x27;</span>); <span class="hljs-comment">//  is OK</span><br></code></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName = <span class="hljs-string">&#x27;Smith&#x27;</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><br><span class="hljs-keyword">let</span> result1 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>); <span class="hljs-comment">// works correctly now, returns &quot;Bob Smith&quot;</span><br><span class="hljs-keyword">let</span> result2 = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// still works, also returns &quot;Bob Smith&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1, result2); <span class="hljs-comment">//  Bob Smith Bob Smith</span><br></code></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p><strong>&#x2F;&#x2F; …restOfName: string[] 一定要放在最后边，和 ES6 的扩展运算符一样</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName = <span class="hljs-string">&#x27;Smith&#x27;</span>, ...restOfName: <span class="hljs-built_in">string</span>[]</span>) &#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName + restOfName.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> employeeName = <span class="hljs-title function_">buildName</span>(<span class="hljs-string">&#x27;Joseph&#x27;</span>, <span class="hljs-string">&#x27;Samuel&#x27;</span>, <span class="hljs-string">&#x27;Lucas&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="解构赋值在-TS-中的使用"><a href="#解构赋值在-TS-中的使用" class="headerlink" title="解构赋值在 TS 中的使用"></a>解构赋值在 TS 中的使用</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">&#123; a, b &#125;: &#123; a: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span> &#125; = &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> &#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">test</span>()); <span class="hljs-comment">//  3</span><br></code></pre></td></tr></table></figure><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p>有时候我我们需要在函数中使用 this 来去指定那个示例对象, TS 提供俩种方式</p><p><strong>方式一： 使用箭头函数 + 配置 noImplicitThis &#x3D; true (不配置 this 是 any)</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> deck = &#123;<br>    <span class="hljs-attr">suits</span>: [<span class="hljs-string">&#x27;hearts&#x27;</span>, <span class="hljs-string">&#x27;spades&#x27;</span>, <span class="hljs-string">&#x27;clubs&#x27;</span>, <span class="hljs-string">&#x27;diamonds&#x27;</span>],<br>    <span class="hljs-attr">cards</span>: <span class="hljs-title class_">Array</span>(<span class="hljs-number">52</span>),<br>    <span class="hljs-attr">createCardPicker</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">52</span>);<br>            <span class="hljs-keyword">let</span> pickedSuit = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(pickedCard / <span class="hljs-number">13</span>);<br><br>            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">suit</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">suits</span>[pickedSuit], <span class="hljs-attr">card</span>: pickedCard % <span class="hljs-number">13</span> &#125;;<br>        &#125;;<br>    &#125;,<br>&#125;;<br><br><span class="hljs-keyword">let</span> cardPicker = deck.<span class="hljs-title function_">createCardPicker</span>();<br><span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title function_">cardPicker</span>();<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;card: &#x27;</span> + pickedCard.<span class="hljs-property">card</span> + <span class="hljs-string">&#x27; of &#x27;</span> + pickedCard.<span class="hljs-property">suit</span>);<br></code></pre></td></tr></table></figure><p><strong>方式二：使用 interface</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Card</span> &#123;<br>    <span class="hljs-attr">suit</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">card</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deck</span> &#123;<br>    <span class="hljs-attr">suits</span>: <span class="hljs-built_in">string</span>[];<br>    <span class="hljs-attr">cards</span>: <span class="hljs-built_in">number</span>[];<br>    <span class="hljs-title function_">createCardPicker</span>(<span class="hljs-attr">this</span>: <span class="hljs-title class_">Deck</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Card</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">deck</span>: <span class="hljs-title class_">Deck</span> = &#123;<br>    <span class="hljs-attr">suits</span>: [<span class="hljs-string">&#x27;hearts&#x27;</span>, <span class="hljs-string">&#x27;spades&#x27;</span>, <span class="hljs-string">&#x27;clubs&#x27;</span>, <span class="hljs-string">&#x27;diamonds&#x27;</span>],<br>    <span class="hljs-attr">cards</span>: <span class="hljs-title class_">Array</span>(<span class="hljs-number">52</span>),<br>    <span class="hljs-attr">createCardPicker</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">52</span>);<br>            <span class="hljs-keyword">let</span> pickedSuit = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(pickedCard / <span class="hljs-number">13</span>);<br><br>            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">suit</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">suits</span>[pickedSuit], <span class="hljs-attr">card</span>: pickedCard % <span class="hljs-number">13</span> &#125;;<br>        &#125;;<br>    &#125;,<br>&#125;;<br><br><span class="hljs-keyword">let</span> cardPicker = deck.<span class="hljs-title function_">createCardPicker</span>();<br><span class="hljs-keyword">let</span> pickedCard = <span class="hljs-title function_">cardPicker</span>();<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;card: &#x27;</span> + pickedCard.<span class="hljs-property">card</span> + <span class="hljs-string">&#x27; of &#x27;</span> + pickedCard.<span class="hljs-property">suit</span>);<br></code></pre></td></tr></table></figure><p>这样 this 就会指向 Deck</p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>&#x2F;&#x2F; 官网的例子太麻烦了， 我以 翻转字符串或者数字来举例</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 翻转 字符串或者数字</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">foo: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">foo: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">foo: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> foo.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> foo === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(foo.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>))<br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverse</span>(‘<span class="hljs-number">123456</span>’));  <span class="hljs-comment">// 字符串类型的 &#x27;654321&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverse</span>(<span class="hljs-number">123456</span>));  <span class="hljs-comment">// 数字类型的 654321</span><br></code></pre></td></tr></table></figure><p>看着是不是好像没什么太大的区别?</p><p><strong>&#x2F;&#x2F; 其实 typescript 重载的意义在于 表意更清楚</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习总结之类</title>
    <link href="/2022/01/03/Typescript%E7%AC%94%E8%AE%B03/"/>
    <url>/2022/01/03/Typescript%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<p>​</p><h2 id="类的注解方式"><a href="#类的注解方式" class="headerlink" title="类的注解方式"></a>类的注解方式</h2><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName;<br>    &#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承中-super"><a href="#继承中-super" class="headerlink" title="继承中 super"></a>继承中 super</h3><p><strong>&#x2F;&#x2F; 注意这个 super， 如果在 constructor 内就是默认指 构造函数 。</strong></p><p><strong>&#x2F;&#x2F; 如果在 constructor 外部（除了 constructor），这个 super 就是指的 父类 （Animal）。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>    &#125; <span class="hljs-comment">// 这里的super  =&gt; constructor Animal(theName: string) : Animal</span><br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Slithering...&#x27;</span>);<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters); <span class="hljs-comment">// 这里的 super =&gt; 父类 Animal</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><blockquote><p>三大类成员修饰符: public &#x2F; private &#x2F; protected</p></blockquote><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>&#x2F;&#x2F; 在 TypeScript 里，成员都默认为 public。</p><p>&#x2F;&#x2F; 如果类默认不写, 就是 public</p><p><strong>public : 公共成员属性</strong></p><ul><li>自身类可以调用</li><li>子类可以调用</li><li>实例可以调用</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>&#x2F;&#x2F; private : 私有属性</p><ul><li>只能自身调用</li></ul><p>&#x2F;&#x2F; 当我把 Animal 类中的 构造函数变成私有, 如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>    &#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Slithering...&#x27;</span>);<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sam = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snake</span>(<span class="hljs-string">&#x27;Sammy the Python&#x27;</span>);<br>sam.<span class="hljs-title function_">move</span>();<br></code></pre></td></tr></table></figure><p><strong>因此 , 可证明 private 只能自身调用, 子类和实例不能调用.</strong></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><blockquote><p>protected 修饰符与 private 修饰符的行为很相似，但有一点不同， protected 成员在派生类中仍然可以访问。</p></blockquote><p>也就是说 protected 可以自身调用,也可以子类调用.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>    &#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Slithering...&#x27;</span>);<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> jack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;jack&#x27;</span>);<br>jack.<span class="hljs-title function_">move</span>(); <span class="hljs-comment">// 报错,</span><br></code></pre></td></tr></table></figure><p>这时,在编辑器上, 实例调用 move 方法会报错,</p><h3 id="readonly-只读-修饰符"><a href="#readonly-只读-修饰符" class="headerlink" title="readonly(只读)修饰符"></a>readonly(只读)修饰符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Octopus</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// readonly 要放在 public 这种访问属性修饰符 后面</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">numberOfLegs</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">8</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName;<br>    &#125;<br>    <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 错误 : 修饰符仅可出现在属性声明或索引签名中</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> dad = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Octopus</span>(<span class="hljs-string">&#x27;Man with the 8 strong legs&#x27;</span>);<br>dad.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Man with the 3-piece suit&#x27;</span>; <span class="hljs-comment">// 错误! name 是只读的.</span><br></code></pre></td></tr></table></figure><p>readonly 注意事项:</p><ul><li><strong>顺序: 要放在 public&#x2F;private&#x2F;protected 之后</strong></li><li><strong>是否可写: 加上 readonly 表示 只读,不可写</strong></li><li><strong>不能修饰成员方法.</strong></li></ul><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><blockquote><p>简写写法</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal1</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><blockquote><p>大概看了一下, 其实就是 getter 和 setter</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> passcode = <span class="hljs-string">&#x27;secret passcode&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">_fullName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;jack&#x27;</span>;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>(): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fullName</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">fullName</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-keyword">if</span> (passcode &amp;&amp; passcode == <span class="hljs-string">&#x27;secret passcode&#x27;</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fullName</span> = newName;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error: Unauthorized update of employee!&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(employee.<span class="hljs-property">fullName</span>); <span class="hljs-comment">// jack</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((employee.<span class="hljs-property">fullName</span> = <span class="hljs-string">&#x27;new jack&#x27;</span>)); <span class="hljs-comment">// new jack</span><br></code></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><blockquote><p>这个也是 不属于 TS 新有的知识, 学到这里,我发现其实我们大都是还是在复习 JS, 要学好 TS 前提是 JS 基础一定要好啊</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Grid</span> &#123;<br>    <span class="hljs-keyword">static</span> origin = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-title function_">calculateDistanceFromOrigin</span>(<span class="hljs-params">point: &#123; x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span> &#125;</span>) &#123;<br>        <span class="hljs-keyword">let</span> xDist = point.<span class="hljs-property">x</span> - <span class="hljs-title class_">Grid</span>.<span class="hljs-property">origin</span>.<span class="hljs-property">x</span>;<br>        <span class="hljs-keyword">let</span> yDist = point.<span class="hljs-property">y</span> - <span class="hljs-title class_">Grid</span>.<span class="hljs-property">origin</span>.<span class="hljs-property">y</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(xDist * xDist + yDist * yDist) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">scale</span>;<br>    &#125;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> scale: <span class="hljs-built_in">number</span></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> grid1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Grid</span>(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 1x scale</span><br><span class="hljs-keyword">let</span> grid2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Grid</span>(<span class="hljs-number">5.0</span>); <span class="hljs-comment">// 5x scale</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grid1.<span class="hljs-title function_">calculateDistanceFromOrigin</span>(&#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">10</span> &#125;));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grid2.<span class="hljs-title function_">calculateDistanceFromOrigin</span>(&#123; <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">10</span> &#125;));<br></code></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote><p>抽象类: 能够提供其他类的基类 , 它们一般不会直接被实例化</p></blockquote><p>抽象类:</p><ol><li>无法创建实例</li><li>在抽象类中 抽象方法一定要实现 (这一点和接口很像)</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">makeSound</span>(): <span class="hljs-built_in">void</span>;<br>    <span class="hljs-title function_">move</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我在移动&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">makeSound</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 一定要去定义这个方法，  因为抽象类中包含这个抽象方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;汪汪汪&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">makeSound</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;喵喵喵&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高阶技巧"><a href="#高阶技巧" class="headerlink" title="高阶技巧"></a>高阶技巧</h3><ol><li>定义类的时候, 定义了一个类型;</li><li>定义类的时候, 定义了一个构造函数;</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-keyword">static</span> standardGreeting = <span class="hljs-string">&#x27;Hello, there&#x27;</span>; <span class="hljs-comment">// 静态属性</span><br>    <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Greeter</span>.<span class="hljs-property">standardGreeting</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">greeter1</span>: <span class="hljs-title class_">Greeter</span>; <span class="hljs-comment">// 定义类型</span><br>greeter1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeter1.<span class="hljs-title function_">greet</span>());<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">greeterMaker</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Greeter</span> = <span class="hljs-title class_">Greeter</span>; <span class="hljs-comment">// 定义类型</span><br>greeterMaker.<span class="hljs-property">standardGreeting</span> = <span class="hljs-string">&#x27;Hey there!&#x27;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">greeter2</span>: <span class="hljs-title class_">Greeter</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">greeterMaker</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeter2.<span class="hljs-title function_">greet</span>());<br></code></pre></td></tr></table></figure><ol start="3"><li>把类当做接口使用</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point3</span>d <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">point3d</span>: <span class="hljs-title class_">Point3</span>d = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> &#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习总结之基础类型</title>
    <link href="/2022/01/02/Typescript%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/01/02/Typescript%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="对-TypeScript-的认识"><a href="#对-TypeScript-的认识" class="headerlink" title="对 TypeScript 的认识"></a>对 TypeScript 的认识</h2><p>TypeScript 是什么？</p><ol><li><p>TypeScript 是 JavaScript 的超集，他扩展了 JavaScript 的语法，所以任何现有的 JavaScript 程序可以不加改变的在 TypeScript 下工作</p></li><li><p>TypeScript 是开发大型应用的基石。</p></li><li><p>TypeScript 提供了更丰富的语法提示， 在编写阶段能够检查错误。</p><p> <strong>与 JavaScript 的区别</strong></p></li></ol><p>TypeScript 是静态类型， JavaScript 是动态类型</p><ol><li>在 TypeScript 中 类型是确定好的。（一旦给类型赋值后就不能更改其类型）</li></ol><h3 id="TypeScript-数据类型"><a href="#TypeScript-数据类型" class="headerlink" title="TypeScript 数据类型"></a>TypeScript 数据类型</h3><blockquote><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p></blockquote><h4 id="JavaScript-的基本数据类型："><a href="#JavaScript-的基本数据类型：" class="headerlink" title="JavaScript 的基本数据类型："></a>JavaScript 的基本数据类型：</h4><p>原始数据类型：string、number、boolean、null、undefined、symbol</p><p>引用数据类型：object</p><p>TypeScript 的基本数据类型：</p><p>包含 JavaScript 所有的基本数据之外，额外新增了几种新的数据类型（大概的写一下）：</p><ol><li>any(任意类型)、</li><li>never （<code>never</code>类型表示的是那些永不存在的值的类型） 、</li><li>void（<code>void</code>类型像是与<code>any</code>类型相反、只能为它赋予<code>undefined</code>和<code>null</code>）</li><li>针对于对象类型的： interface</li><li>针对于数组的：number[] 、string[] 、boolean[] 等， 泛型的写法：Array&lt;元素类型&gt; (Array<number>)</li><li>函数的注解</li></ol><h4 id="TypeScript-原始数据的注解"><a href="#TypeScript-原始数据的注解" class="headerlink" title="TypeScript 原始数据的注解"></a>TypeScript 原始数据的注解</h4><h5 id="布尔值的注解-："><a href="#布尔值的注解-：" class="headerlink" title="布尔值的注解 ："></a>布尔值的注解 ：</h5><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">isDone</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;注意 boolean 首字母不能大写</p><h5 id="数字的注解："><a href="#数字的注解：" class="headerlink" title="数字的注解："></a>数字的注解：</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">decLiteral</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><h5 id="字符串的注解："><a href="#字符串的注解：" class="headerlink" title="字符串的注解："></a>字符串的注解：</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">myName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;bob&quot;</span>;<br>myName = <span class="hljs-string">&quot;smith&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123; myName &#125;</span>.</span><br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 注意这点不能用 name 来命名</p><h5 id="any-数据类型：-任意数据类型；"><a href="#any-数据类型：-任意数据类型；" class="headerlink" title="any 数据类型： 任意数据类型；"></a>any 数据类型： 任意数据类型；</h5><ol><li><p><strong>如果是不同变量的话，可以是任意的数据类型</strong></p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br>notSure = <span class="hljs-string">&#x27;maybe a string instead&#x27;</span>;<br>notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// okay, definitely a boolean</span><br></code></pre></td></tr></table></figure></li><li><p><strong>如果是对象的话， any 是不能够提示原型上的共有属性和方法的。</strong></p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>;<br>notSure.<span class="hljs-title function_">ifItExists</span>(); <span class="hljs-comment">// okay, ifItExists might exist at runtime</span><br>notSure.<span class="hljs-title function_">toFixed</span>(); <span class="hljs-comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span><br></code></pre></td></tr></table></figure><p> 相反，如果是 Object 的话，它就会提示使用 Object 类型上的属性</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">prettySure</span>: <span class="hljs-title class_">Object</span> = <span class="hljs-number">4</span>;<br>prettySure.<span class="hljs-title function_">toFixed</span>(); <span class="hljs-comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span><br>prettySure.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure></li><li><p><strong>未给初始值的变量类型 为 any 类型</strong></p> <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> a;<br>a = <span class="hljs-string">&#x27;123&#x27;</span>;<br>a = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure></li></ol><h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><blockquote><p>void<code>类型像是与</code>any<code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 </code>void</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This is my warning message&#x27;</span>);<br>    <span class="hljs-comment">//相当于 return undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="null-amp-undefined"><a href="#null-amp-undefined" class="headerlink" title="null &amp; undefined"></a>null &amp; undefined</h5><blockquote><p>默认情况下 null 和 undefined 是所有类型的子类型</p></blockquote><p>在 tsconfig.json 中配置 strictNullChecks &#x3D; false 时，<br>就可证明 null 和 undefined 是所有类型的子类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">u</span>: <span class="hljs-built_in">number</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// strictNullChecks = false 时， 不报错</span><br></code></pre></td></tr></table></figure><blockquote><p>但官方建议让我们 strictNullChecks &#x3D; true ，但在配置中这个标记是关闭的。</p></blockquote><h5 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h5><p><code>never</code>类型表示的是那些永不存在的值的类型, 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code>类型，当它们被永不为真的类型保护所约束时。</p><p>（目前我接触的这种实际情景不多，以后遇到了我再去单独了解）</p><h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><p>object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">o: <span class="hljs-built_in">object</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-built_in">void</span>;<br><br><span class="hljs-title function_">create</span>(&#123; <span class="hljs-attr">prop</span>: <span class="hljs-number">0</span> &#125;); <span class="hljs-comment">// OK</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// OK</span><br><br><span class="hljs-title function_">create</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-string">&#x27;string&#x27;</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// Error</span><br><span class="hljs-title function_">create</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>以上是官网的例子， 上面代码说明了 object 不能是去使用 原始类型 ， 比如<code>create(function()&#123;&#125;)</code>、 <code>create([])</code> 这些是可以 OK 的。</p><h3 id="类型注解-amp-类型推论-amp-联合类型"><a href="#类型注解-amp-类型推论-amp-联合类型" class="headerlink" title="类型注解 &amp; 类型推论 &amp; 联合类型"></a>类型注解 &amp; 类型推论 &amp; 联合类型</h3><p>在我们定义变量时，而这个变量是原始数据，那么，我们不需要对它进行类型注解，它也能推论出该变量属于什么类型的。</p><p><strong>所以正常情况下，能够做出类型推论的话，我们专门去对它注解，会显得有些繁琐了。</strong></p><p>但是肯定有别的情况需要我们去做类型注解，</p><p>比如：当我们定义一个方式， 它会提示我们去进行类型注解</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-comment">// 在编辑器中会提示你要做类型注解</span><br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>做类型注解：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>联合类型：</strong> 多个类型当中，我们可以选择其中类型的一种</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">union</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>union = <span class="hljs-string">&#x27;123&#x27;</span>; <span class="hljs-comment">// is OK</span><br>union = <span class="hljs-number">123</span>; <span class="hljs-comment">// is OK</span><br></code></pre></td></tr></table></figure><p>而当我们去定义一个函数时：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 共有属性， OK</span><br>    <span class="hljs-comment">//  return  a.split()  // 这个是 String 独有的属性，不能联合起来使用</span><br>&#125;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>因此，我们要注意，</p><ol><li><p>联合类型的共有属性不会报错，</p><p> 但不要用 联合类型中其中一种类型的独有属性 比如 String 中的 split 方法， Number 是没有此属性的， 因此会报错</p></li><li><p>在赋值的时候要确认类型</p></li></ol><h3 id="初识-interface"><a href="#初识-interface" class="headerlink" title="初识 interface"></a>初识 interface</h3><blockquote><p>接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p></blockquote><ol><li>对对象的形状进行描述；</li><li>对类的一部分行为的抽象；</li></ol><p>简单使用：(对 对象的形状进行描述)</p><p><strong>&#x2F;&#x2F; interface 默认不能多属性也不能少属性</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">preson</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>可选属性：如果偏偏少属性呢？ 就在属性后边加<code>?</code>即可。 如果想多属性呢，</strong></li><li><strong>任意&#x2F;多选 属性<code>[propName:string]:any</code></strong></li><li><strong>只读属性: <code>readonly</code>后面加属性</strong></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">readonly</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 只读属性</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    age?: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 可选属性</span><br>    [<span class="hljs-attr">propName</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>; <span class="hljs-comment">// 任意属性</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">preson</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wpf&#x27;</span>,<br>    <span class="hljs-attr">male</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数组注解"><a href="#数组注解" class="headerlink" title="数组注解"></a>数组注解</h3><p>定义数组的方式有三种：</p><ol><li>类型[] 如： number[]</li><li>数组泛型 Array&lt;类型&gt; 如： Array<number></li><li>interface 方式</li></ol><p><strong>类型[]</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 默认不写，会类型推论 推出来</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">list1</span>: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;1&#x27;</span>]; <span class="hljs-comment">// 联合类型</span><br></code></pre></td></tr></table></figure><p><strong>Array&lt;类型&gt;</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p><strong>interface 方式</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span> &#123;<br>    [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">List</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span> &#123;<br>    [<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">list</span>: <span class="hljs-title class_">List</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>];<br></code></pre></td></tr></table></figure><p><strong>类数组</strong></p><p>&#x2F;&#x2F; args 就是个类数组</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-Cli脚手架</title>
    <link href="/2021/12/28/Vue-Cli%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <url>/2021/12/28/Vue-Cli%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-CLI-脚手架"><a href="#Vue-CLI-脚手架" class="headerlink" title="Vue-CLI 脚手架"></a>Vue-CLI 脚手架</h1><blockquote><p><a href="https://cli.vuejs.org/zh/">Vue CLI</a> 是 Vue 的脚手架工具，它可以帮助我们快速生成 Vue 基础项目代码，提供开箱即用的功能特性。</p></blockquote><ul><li>为什么需要使用 Vue-CLI<ul><li>使用 Vue.js 开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。</li><li>如果每个项目都要手动完成这些工作，那无以效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。</li></ul></li></ul><h2 id="1-Vue-CLI-的使用"><a href="#1-Vue-CLI-的使用" class="headerlink" title="1 Vue-CLI 的使用"></a>1 Vue-CLI 的使用</h2><ul><li><p>安装 Vue 脚手架</p><ul><li>&#96;&#96;&#96;shell<br>npm install -g @vue&#x2F;cli@版本号<figure class="highlight autohotkey"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs autohotkey"><br>-   Vue CLI2 初始化项目<br><br>    -   ```shell<br>        vue init webpack my-project<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Vue CLI3 初始化项目</p><ul><li>&#96;&#96;&#96;shell<br>vue create my-project<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">## 2 Vue-CLI2 详解</span><br><br><span class="hljs-comment">### 2.1 步骤详解</span><br><br>![image-<span class="hljs-number">20200923112538728</span>](https:<span class="hljs-regexp">//i</span>.loli.net<span class="hljs-regexp">/2020/</span><span class="hljs-number">09</span><span class="hljs-regexp">/25/g</span>Xfdbyo7erTmz19.png)<br><br><span class="hljs-comment">### 2.2 目录详解</span><br><br>![image-<span class="hljs-number">20200923112626821</span>](https:<span class="hljs-regexp">//i</span>.loli.net<span class="hljs-regexp">/2020/</span><span class="hljs-number">09</span><span class="hljs-regexp">/25/</span><span class="hljs-number">9</span>eP2bklLcqVTywp.png)<br><br><span class="hljs-comment">## 3 Runtime-Compiler 和 Runtime-only 的区别</span><br><br>-   **<span class="hljs-number">1</span>、Runtime-Compiler 和 Runtime-only 的 main.js 文件的区别：**<br><br>```javascript<br><span class="hljs-regexp">//</span>（<span class="hljs-number">1</span>） Runtime-Compiler<br>new Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  components: &#123; App &#125;,<br>  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span><br>&#125;)<br><br><span class="hljs-regexp">//</span> （<span class="hljs-number">2</span>）Runtime-only<br>new Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  render: h =&gt; h(App)<br>&#125;)<br><br><span class="hljs-regexp">//</span> Runtime-Complier 解析过程：<br>第一步：将template模板转换成抽象语法树（ast）;<br>第二步：通过render函数将抽象语法树转换成虚拟DOM（vdom）;<br>第三步：将虚拟DOM转换成真正的DOM；<br>template =&gt; 抽象语法树(ast) =&gt; render() =&gt; 虚拟DOM(vdom) =&gt; 页面<br><br><span class="hljs-regexp">//</span> Runtime-only 解析过程：<br>第一步：vue-template-compiler插件直接将组件转换成 render函数；<br>第二步：将render函数返回的虚拟DOM转换成页面；<br>render() =&gt; 虚拟DOM(vdom) =&gt; 页面；<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>2.render()函数</strong></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> render = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> _vm = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> _h = _vm.<span class="hljs-property">$createElement</span>;<br>    <span class="hljs-keyword">var</span> _c = _vm.<span class="hljs-property">_self</span>.<span class="hljs-property">_c</span> || _h;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_c</span>(<br>        <span class="hljs-string">&#x27;div&#x27;</span>,<br>        &#123; <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;app&#x27;</span> &#125; &#125;,<br>        [<br>            <span class="hljs-title function_">_c</span>(<span class="hljs-string">&#x27;img&#x27;</span>, &#123; <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-attr">src</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./assets/logo.png&#x27;</span>) &#125; &#125;),<br>            _vm.<span class="hljs-title function_">_v</span>(<span class="hljs-string">&#x27; &#x27;</span>),<br>            <span class="hljs-title function_">_c</span>(<span class="hljs-string">&#x27;router-view&#x27;</span>),<br>        ],<br>        <span class="hljs-number">1</span><br>    );<br>&#125;;<br><span class="hljs-comment">// render函数返回的是虚拟DOM</span><br></code></pre></td></tr></table></figure><ul><li><ol start="3"><li>俩者的区别对比</li></ol></li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">（1）Runtime-only性能更高；<br>（2）Runtime-only代码量更少；<br></code></pre></td></tr></table></figure><h2 id="4-Vue-CLI3-详解"><a href="#4-Vue-CLI3-详解" class="headerlink" title="4 Vue-CLI3 详解"></a>4 Vue-CLI3 详解</h2><p><strong>CLI2 和 CLI3 的区别</strong></p><ul><li>vue-cli 3 与 2 版本有很大区别<ul><li>vue-cli 3 是基于 webpack 4 打造，vue-cli 2 还是 webapck 3</li><li>vue-cli 3 的设计原则是“<strong>0 配置”，移除的配置文件根目录下的，build 和 config 等目录</strong></li><li>vue-cli 3 提供了 vue ui 命令，提供了可视化配置，更加人性化</li><li><strong>移除了 static 文件夹，新增了 public 文件夹，并且 index.html 移动到 public 中</strong></li></ul></li></ul><h3 id="4-1-安装步骤详解"><a href="#4-1-安装步骤详解" class="headerlink" title="4.1 安装步骤详解"></a>4.1 安装步骤详解</h3><p><img src="https://i.loli.net/2020/09/25/sXYTBZDdym5GiF4.png" alt="image-20200923113522511"></p><h3 id="4-2-目录结构详解"><a href="#4-2-目录结构详解" class="headerlink" title="4.2 目录结构详解"></a>4.2 目录结构详解</h3><p><img src="https://i.loli.net/2020/09/25/F6ybPXaMpt8vSIh.png" alt="image-20200923113601396"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuerouter前端路由</title>
    <link href="/2021/12/27/Vue-router%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2021/12/27/Vue-router%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-router-前端路由"><a href="#Vue-router-前端路由" class="headerlink" title="Vue-router 前端路由"></a>Vue-router 前端路由</h1><blockquote><p>前端路由核心： 改变 URL，但是页面不进行整体的刷新。</p></blockquote><h2 id="1-单页面导航路径"><a href="#1-单页面导航路径" class="headerlink" title="1 单页面导航路径"></a>1 单页面导航路径</h2><blockquote><p>URL.hash 和 HTML5 history</p></blockquote><h3 id="URL-hash"><a href="#URL-hash" class="headerlink" title="URL.hash"></a>URL.hash</h3><blockquote><p>URL 的 hash 也就是锚点(#), 本质上是改变 window.location 的 href 属性.<br>我们可以通过直接赋值 location.hash 来改变 href, 但是页面不发生刷新</p></blockquote><ul><li><p><strong>路径</strong> （使用 url.hash）</p><ul><li>一般使用描点来表示路径，也就是 hash 作为页面导航的路径标识</li><li>为什么？ 因为<strong>正常的 url 地址会发请求，而 hash 描点不会发送请求刷新页面</strong></li></ul></li><li><p><strong>VueRouter 内部监视了 hash 的改变 ——- window.onhashchange</strong></p></li><li><p>然后根据 hash 的改变去展示路由规则中的配置组件</p></li><li><p>VueRouter 默认要求 hash 导航路径都以 #&#x2F;开头</p><ul><li>为什么？</li><li>主要是为了和正常的 hash 锚点（网页内部定位、id）做区别</li><li>例如我们使用锚点内部定位的时候，需要给元素起 id，我们几乎不会给 id 起名为 &#x2F;xxx</li><li>如果 VueRouter 没有 #&#x2F; 的规则 ，例如直接 #foo 就可能会你锚点的那个 id foo 冲突</li></ul></li></ul><p><strong>因为有 url.hash 这样的设置使得 url 不美观， 那么我们可以使用 HTML5 新增属性 history 的方法</strong></p><ul><li>VueRouter 默认是 hash 路径模式</li><li>它页支持传统的 url 模式（HTML history）</li></ul><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><ul><li>优点 — 优雅、同构应用友好</li><li>hash 模式<ul><li>兼容性更好，不需要后端处理任何配置</li><li>file 协议或是 http 协议都可以运行</li><li>比较丑，不能用于服务端渲染同构开发</li></ul></li><li>history 模式<ul><li>相比 hash 浏览器 兼容不太好，需要后端特殊配置</li><li>必须运行在 http|https 服务中</li><li>url 简洁美观，如果需要做服务端渲染同构开发，则必须使用 history 模式</li><li>注意： 使用了 history 模式之后，不要在模板中直接使用普通的 a 链接去跳转，一定要使用 router-link 或者 router.push 进行导航</li></ul></li></ul><p><strong>history 有五种模式改变 URL 而不刷新页面.</strong></p><ul><li><strong>history.pushState()</strong></li><li><strong>history.replaceState()</strong> 和 pushState 的区别是 不能返回</li><li><strong>history.go()</strong></li><li>**history.back() ** 等价于 history.go(-1)</li><li><strong>history.forward()</strong> 则等价于 history.go(1)</li></ul><h2 id="2-vue-router-安装和使用"><a href="#2-vue-router-安装和使用" class="headerlink" title="2 vue-router 安装和使用"></a>2 vue-router 安装和使用</h2><ul><li><p>vue-router 是基于路由和组件的</p><ul><li>路由用于设定访问路径, 将路径和组件映射起来.</li><li>在 vue-router 的单页面应用中, 页面的路径的改变就是组件的切换.</li></ul></li><li><p>步骤一: 安装 vue-router</p><ul><li><div class="code-wrapper"><pre><code class="shell">npm install vue-router --save<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs php"><br>-   步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过 Vue.<span class="hljs-keyword">use</span>()来安装路由功能)<br><br>    -   第一步：导入路由对象，并且调用 Vue.<span class="hljs-keyword">use</span>(VueRouter)<br><br>        -   ```javascript<br>            import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br>            import VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br>            <span class="hljs-comment">// 1. 调用插件</span><br>            Vue.<span class="hljs-keyword">use</span>(VueRouter);<br></code></pre></td></tr></table></figure></code></pre></li><li><p>第二步：创建路由实例，并且传入路由映射配置</p></li><li><p>第三步：在 Vue 实例中挂载创建的路由实例</p></li></ul></li><li><p>使用 vue-router 的步骤:</p><ul><li>第一步: 创建路由组件</li><li>第二步: 配置路由映射: 组件和路径映射关系</li><li>第三步: 使用路由: 通过<router-link>和<router-view></li></ul></li></ul><h3 id="2-1-创建-Vue-实例"><a href="#2-1-创建-Vue-实例" class="headerlink" title="2.1 创建 Vue 实例"></a>2.1 创建 Vue 实例</h3><p><img src="https://i.loli.net/2020/09/25/Rl9VBz1wrFqoIbg.png" alt="1"></p><h3 id="2-2-挂载到-Vue-实例中"><a href="#2-2-挂载到-Vue-实例中" class="headerlink" title="2.2 挂载到 Vue 实例中"></a>2.2 挂载到 Vue 实例中</h3><p><img src="https://img-blog.csdnimg.cn/2020092614545839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="挂载到Vue实例中"></p><h3 id="2-3-步骤一：创建路由组件"><a href="#2-3-步骤一：创建路由组件" class="headerlink" title="2.3 步骤一：创建路由组件"></a>2.3 步骤一：创建路由组件</h3><p><img src="https://i.loli.net/2020/09/25/rTXEdiZAHeUvQ3P.png" alt="3"></p><h3 id="2-4-步骤二：配置组件和路径的映射关系"><a href="#2-4-步骤二：配置组件和路径的映射关系" class="headerlink" title="2.4 步骤二：配置组件和路径的映射关系"></a>2.4 步骤二：配置组件和路径的映射关系</h3><p><img src="https://img-blog.csdnimg.cn/20200926145610781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="配置组件和路径的映射关系"></p><h3 id="2-5-步骤三：使用路由"><a href="#2-5-步骤三：使用路由" class="headerlink" title="2.5 步骤三：使用路由."></a>2.5 步骤三：使用路由.</h3><p><img src="https://i.loli.net/2020/09/25/W9mfNcFsjC3Jy7e.png" alt="5"></p><h3 id="最终效果如下"><a href="#最终效果如下" class="headerlink" title="最终效果如下"></a>最终效果如下</h3><p><img src="https://img-blog.csdnimg.cn/20200926145610812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="最终效果"></p><h3 id="2-6-路由的默认路径"><a href="#2-6-路由的默认路径" class="headerlink" title="2.6 路由的默认路径"></a>2.6 路由的默认路径</h3><ul><li>我们这里还有一个不太好的实现:<ul><li>默认情况下, 进入网站的首页, 我们希望<router-view>渲染首页的内容.</li><li>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    &#125;,<br>];<br></code></pre></td></tr></table></figure><ul><li>配置解析:<ul><li>我们在 routes 中又配置了一个映射.</li><li>path 配置的是根路径: &#x2F;</li><li>redirect 是重定向, 也就是我们将根路径重定向到&#x2F;home 的路径下, 这样就可以得到我们想要的结果了.</li></ul></li></ul><h3 id="2-7-使用-HTML5-history-模式"><a href="#2-7-使用-HTML5-history-模式" class="headerlink" title="2.7 使用 HTML5 history 模式"></a>2.7 使用 HTML5 history 模式</h3><ul><li>我们前面说过改变路径的方式有两种:<ul><li>URL 的 hash</li><li>HTML5 的 history</li><li>默认情况下, 路径的改变使用的 URL 的 hash.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  2. 创建 Router 实例对象 并 导出它</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>    <span class="hljs-comment">// 3.  routes 属性： 配置路由和组件之间的映射关系</span><br>    routes,<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-comment">// 默认是 hash 模式，</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-8-router-link-的补充"><a href="#2-8-router-link-的补充" class="headerlink" title="2.8 router-link 的补充"></a>2.8 router-link 的补充</h3><ul><li><strong>tag</strong>: tag 可以指定<router-link>之后渲染成什么组件, 比如上面的代码会被渲染成一个<li>元素, 而不是<a></li><li><strong>replace:</strong> replace 不会留下 history 记录, 所以指定 replace 的情况下, 后退键返回不能返回到上一个页面中</li><li><strong>active-class</strong>: 当<router-link>对应的路由匹配成功时, 会自动给当前元素设置一个 router-link-active 的 class, 设置 active-class 可以修改默认的名称.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- tag: tag可以指定&lt;router-link&gt;之后渲染成什么组件, 比如上面的代码会被渲染成一个&lt;li&gt;元素, 而不是&lt;a&gt; --&gt;</span><br>        <span class="hljs-comment">&lt;!-- replace : replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span> <span class="hljs-attr">replace</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">replace</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;/user/&#x27;+id&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>用户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;wpf&#x27;,age:&#x27;23&#x27;,sex:&#x27;男&#x27;&#125;&#125;&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span></span><br><span class="hljs-tag">            &gt;</span>档案&lt;/router-link<br>        &gt;<br><br>        <span class="hljs-comment">&lt;!-- &lt;button @click=&quot;homeClick&quot;&gt;首页&lt;/button&gt;</span><br><span class="hljs-comment">    &lt;button @click=&quot;loginClick&quot;&gt;登录&lt;/button&gt;--&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- inlcude（包含） -- 只有匹配的组件才会被缓存</span><br><span class="hljs-comment">    exclude（排除） -- 除了这些组件都会被缓存--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&quot;User,Profile&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;wpfzzz&#x27;</span>,</span><br><span class="language-javascript">            &#125;;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.router-link-active</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#f00</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-9-路由代码跳转"><a href="#2-9-路由代码跳转" class="headerlink" title="2.9 路由代码跳转"></a>2.9 路由代码跳转</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;homeClick&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;loginClick&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-title function_">homeClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.$router.push(&quot;/htmo&quot;);</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/htmo&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> err);;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;home&quot;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">loginClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this.$router.push(&quot;/login&quot;);</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;/login&quot;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> err);;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;login&quot;</span>);<br>  &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="2-10-动态路由"><a href="#2-10-动态路由" class="headerlink" title="2.10 动态路由"></a>2.10 动态路由</h3><ul><li>在某些情况下，一个页面的 path 路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：<ul><li>&#x2F;user&#x2F;aaaa 或&#x2F;user&#x2F;bbbb</li><li>除了有前面的&#x2F;user 之外，后面还跟上了用户的 ID</li><li>这种 path 和 Component 的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;/user/&#x27;+id&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>用户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;wpf&#x27;,age:&#x27;23&#x27;,sex:&#x27;男&#x27;&#125;&#125;&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span></span><br><span class="hljs-tag">    &gt;</span>档案&lt;/router-link<br>&gt;<br>// 注意： 要使用 v-bind 动态绑定 这样可以获取data中的数据， 否则是个字符串<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  path<span class="hljs-punctuation">:</span> &#x27;/user/<span class="hljs-punctuation">:</span>userId&#x27;<span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 这个</span><br>  component<span class="hljs-punctuation">:</span> User<span class="hljs-punctuation">,</span><br>  meta<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    title<span class="hljs-punctuation">:</span> &#x27;用户&#x27;<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.params.userId&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-路由懒加载"><a href="#3-路由懒加载" class="headerlink" title="3 路由懒加载"></a>3 路由懒加载</h2><ul><li><p>为什么要使用懒加载</p><ul><li>首先, 我们知道路由中通常会定义很多不同的页面.</li><li>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个 js 文件中.</li><li>但是, 页面这么多放在一个 js 文件中, 必然会造成这个页面非常的大.</li><li>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况.</li><li>如何避免这种情况呢? 使用路由懒加载就可以了.</li></ul></li><li><p>路由懒加载可以做什么？</p><ul><li><strong>路由懒加载的主要作用就是将路由对应的组件打包成一个个的 js 代码块.</strong></li><li><strong>只有在这个路由被访问到的时候, 才加载对应的组件</strong></li></ul></li></ul><p><strong>路由懒加载后的效果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200926145610878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="路由懒加载后的效果"></p><h3 id="3-1-懒加载的方式"><a href="#3-1-懒加载的方式" class="headerlink" title="3.1 懒加载的方式"></a>3.1 懒加载的方式</h3><ul><li><p><strong>方式一: 结合 Vue 的异步组件和 Webpack 的代码分析.</strong></p><ul><li>&#96;&#96;&#96;javascript<br>const Home &#x3D; (resolve) &#x3D;&gt; {<br>require.ensure([‘..&#x2F;components&#x2F;Home.vue’], () &#x3D;&gt; {<br>    resolve(require(‘..&#x2F;components&#x2F;Home.vue’));<br>});<br>};<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><br>-   **方式二: AMD 写法**<br><br>    -   ```javascript<br>        const About = <span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;../components/About.vue&#x27;</span>], resolve);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>方式三: 在 ES6 中, 我们可以有更加简单的写法来组织 Vue 异步组件和 Webpack 的代码分割.</strong></p><ul><li>&#96;&#96;&#96;javascript<br>const Home &#x3D; () &#x3D;&gt; import(‘..&#x2F;components&#x2F;Home.vue’);<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><br>```javascript<br>// <span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span><br>// <span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Login.vue&#x27;</span><br>// <span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/User.vue&#x27;</span>;<br><br>// 使用路由懒加载<br>const Home = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Home.vue&#x27;</span>);<br>const HomeNews = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/HomeNews.vue&#x27;</span>);<br>const HomeMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/HomeMessage.vue&#x27;</span>);<br>const Login = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Login.vue&#x27;</span>);<br>const User = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/User.vue&#x27;</span>);<br>const Profile = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Profile.vue&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-嵌套路由的使用"><a href="#4-嵌套路由的使用" class="headerlink" title="4 嵌套路由的使用"></a>4 嵌套路由的使用</h2><ul><li>嵌套路由是一个很常见的功能<ul><li>比如在 home 页面中, 我们希望通过&#x2F;home&#x2F;news 和&#x2F;home&#x2F;message 访问一些内容.</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件.</li></ul></li><li>实现嵌套路由有两个步骤:<ul><li>创建对应的子组件, 并且在路由映射中配置对应的子路由.</li><li>在组件内部使用<router-view>标签.</li></ul></li></ul><h2 id="5-传递参数"><a href="#5-传递参数" class="headerlink" title="5 传递参数"></a>5 传递参数</h2><h3 id="5-1-传递参数的俩种方式-params-和-query"><a href="#5-1-传递参数的俩种方式-params-和-query" class="headerlink" title="5.1 传递参数的俩种方式 params 和 query"></a>5.1 传递参数的俩种方式 params 和 query</h3><blockquote><p>传递参数主要有两种类型: params 和 query</p></blockquote><ul><li>params 的类型: <strong>(参考 10.2.10 动态路由)</strong><ul><li>配置路由格式: <strong>&#x2F;router&#x2F;:id</strong></li><li>传递的方式: <strong>在 path 后面跟上对应的值</strong></li><li>传递后形成的路径: <strong>&#x2F;router&#x2F;123, &#x2F;router&#x2F;abc</strong></li></ul></li><li>query 的类型:<ul><li>配置路由格式: &#x2F;router, 也就是普通配置</li><li>传递的方式: 对象中使用 query 的 key 作为传递方式</li><li>传递后形成的路径: &#x2F;router?id&#x3D;123, &#x2F;router?id&#x3D;abc</li></ul></li></ul><h3 id="5-2-query-参数传递方式一："><a href="#5-2-query-参数传递方式一：" class="headerlink" title="5.2 query 参数传递方式一："></a>5.2 query 参数传递方式一：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;wpf&#x27;,age:&#x27;23&#x27;,sex:&#x27;男&#x27;&#125;&#125;&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;button&quot;</span></span><br><span class="hljs-tag">    &gt;</span>档案&lt;/router-link<br>&gt;<br>// 注意： 要使用 v-bind 动态绑定 这样可以获取data中的数据， 否则是个字符串<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>档案页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-query-参数传递方式二："><a href="#5-3-query-参数传递方式二：" class="headerlink" title="5.3 query 参数传递方式二："></a>5.3 query 参数传递方式二：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toProfile&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">mehtods</span>:&#123;<br>    <span class="hljs-title function_">toProfile</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br>            <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/proflie&#x27;</span>,<br>            <span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;wpf&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">23</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>档案页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;$route.query.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6-router-和-route-的区别"><a href="#6-router-和-route-的区别" class="headerlink" title="6 router 和 route 的区别"></a>6 router 和 route 的区别</h2><ul><li>$route和$router 是有区别的<ul><li>$router为VueRouter实例，想要导航到不同URL，则使用$router.push 方法</li><li>$route 为当前 router 跳转对象里面可以获取 name、path、query、params 等</li></ul></li></ul><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p><strong>router 是 VueRouter 的一个对象</strong>，通过 Vue.use(VueRouter)和 VueRouter 构造函数得到一个 router 的实例对象，这个对象中是一个<strong>全局的对象</strong>，他包含了所有的路由包含了许多关键的对象和属性。</p><p>举例：history 对象</p><p><code>$router.push(&#123;path:&#39;home&#39;&#125;); </code> 本质是向 history 栈中添加一个路由，在我们看来是 切换路由，但本质是在添加一个 history 记录方法</p><p><code>$router.replace(&#123;path:&#39;home&#39;&#125;);</code> 替换路由，没有历史记录</p><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p><strong>route 是一个跳转的路由对象</strong>，每一个路由都会有一个 route 对象，是一个<strong>局部的对象，</strong>可以获取对应的 name,path,params,query 等</p><p><code>$route.path </code><br>字符串，等于当前路由对象的路径，会被解析为绝对路径，如 <code>&quot;/home/news&quot;</code> 。</p><p><code>$route.params </code><br>对象，包含路由中的动态片段和全匹配片段的键值对</p><p><code>$route.query </code><br>对象，包含路由中查询参数的键值对。例如，对于 <code>/home/news/detail/01?favorite=yes</code> ，会得到<code>$route.query.favorite == &#39;yes&#39;</code> 。</p><p><code>$route.router </code><br>路由规则所属的路由器（以及其所属的组件）。</p><p><code>$route.matched </code><br>数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p><p><code>$route.name </code><br>当前路径的名字，如果没有使用具名路径，则名字为空。</p><p><code>$route.path, $route.params, $route.name, $route.query</code> 这几个属性很容易理解，主要用于接收路由传递的参数</p><h2 id="7-导航守卫"><a href="#7-导航守卫" class="headerlink" title="7 导航守卫"></a>7 导航守卫</h2><blockquote><h3 id="什么是导航守卫？"><a href="#什么是导航守卫？" class="headerlink" title="什么是导航守卫？"></a>什么是导航守卫？</h3><p>笼统的说，导航守卫是控制用户能够进入哪些路由和不能进入哪些路由的控制器，也就是管理路由的</p><p>打比方，在你第一次进入 csdn 网站，想写博客时，你必须先登录，才能进入博客编写；登陆界面就好比你能进入的路由，而博客是你不能进入的路由，当你登陆后，控制器才会给你权限，才能进入博客路由，这就是<strong>导航守卫</strong>的用途</p></blockquote><p><strong>全局路由 要在 main.js 文件下创建</strong></p><p>想用<strong>导航守卫</strong>先要有路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>    <span class="hljs-attr">routes</span>: [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/menu&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;menu&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Menu</span> &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Admin</span> &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;about&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,<br>            <span class="hljs-attr">redirect</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;contactLink&#x27;</span> &#125;,<br>            <span class="hljs-attr">children</span>: [<br>                <span class="hljs-comment">//二级路由</span><br>                &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about/contact&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;contactLink&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Contact</span> &#125;,<br>                &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/history&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;historyLink&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">History</span> &#125;,<br>                &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/delivery&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;deliveryLink&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Delivery</span> &#125;,<br>                &#123;<br>                    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/orderingGuide&#x27;</span>,<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;orderingGuideLink&#x27;</span>,<br>                    <span class="hljs-attr">component</span>: <span class="hljs-title class_">OrderingGuide</span>,<br>                    <span class="hljs-attr">redirect</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;phonelink&#x27;</span> &#125;,<br>                    <span class="hljs-attr">children</span>: [<br>                        <span class="hljs-comment">//三级路由</span><br>                        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/phone&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;phonelink&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Phone</span> &#125;,<br>                        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/name&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;namelink&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Name</span> &#125;,<br>                    ],<br>                &#125;,<br>            ],<br>        &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span> &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Register</span> &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/&#x27;</span> &#125;,<br>    ],<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>利用上面路由对象 router 的方法 beforeEach() 实现导航守卫</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><br><span class="hljs-comment">//to:跳转到的路由 from:从哪个路由离开  next:显示函数</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/login&#x27;</span> || to.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/register&#x27;</span>) &#123;<br>        <span class="hljs-title function_">next</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请先登录&#x27;</span>);<br>        <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>‘&#x2F;login’ ‘&#x2F;register’ 为自己定义的路由地址</p><p>to.path 为跳转到的路由地址</p><p>next() 为显示当前路由内容</p><p>next(‘&#x2F;login’) 跳转到指定路由并显示指定路由的内容</p><p>to 对象可获取的信息（console.log(to) 查看）</p><p><img src="https://img-blog.csdn.net/20180823114816241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MDg5NTAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="7-1-全局守卫"><a href="#7-1-全局守卫" class="headerlink" title="7.1 全局守卫"></a>7.1 全局守卫</h3><h4 id="前置守卫"><a href="#前置守卫" class="headerlink" title="前置守卫 :"></a><strong>前置守卫 :</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;&#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>回调函数中的参数，</strong><ul><li><strong>to：进入到哪个路由去</strong></li><li><strong>from：从哪个路由离开</strong></li><li><strong>next：函数，决定是否展示你要看到的路由页面。</strong></li></ul></li></ul><h4 id="后置钩子"><a href="#后置钩子" class="headerlink" title="后置钩子:"></a><strong>后置钩子:</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;&#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>只有两个参数，</strong><ul><li><strong>to：进入到哪个路由去，</strong></li><li><strong>from：从哪个路由离。</strong></li></ul></li></ul><h3 id="7-2-组件守卫"><a href="#7-2-组件守卫" class="headerlink" title="7.2 组件守卫"></a>7.2 组件守卫</h3><blockquote><p>在路由组件内直接定义以下路由导航守卫：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;<br>    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span><br>    <span class="hljs-comment">// 不能！！！ 获取组件实例中的 `this`</span><br>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span><br>&#125;,<br><span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;<br>    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>&#125;,<br><span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)&#123;<br>    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li></ol><h3 id="7-3-keep-alive"><a href="#7-3-keep-alive" class="headerlink" title="7.3 keep-alive"></a>7.3 keep-alive</h3><blockquote><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p></blockquote><p><strong>props（ 属性）</strong>：</p><ul><li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li>max - 数字。最多可以缓存多少组件实例。</li></ul><p><strong>生命周期函数</strong></p><p><strong>1. activated</strong></p><p>在 keep-alive 组件激活时调用<br>       该钩子函数在服务器端渲染期间不被调用</p><p><strong>2. deactivated</strong></p><p>在 keep-alive 组件停用时调用<br>       该钩子在服务器端渲染期间不被调用</p><p>被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated</p><p>使用 keep-alive 会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在 activated 阶段获取数据，承担原来 created 钩子函数中获取数据的任务。</p><p><strong>注意：</strong> 只有组件被 keep-alive 包裹时，这两个生命周期函数才会被调用，如果作为正常组件使用，是不会被调用的，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子函数依然不会被调用！另外，在服务端渲染时，此钩子函数也不会被调用。</p><p><strong>缓存所有页面</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>根据条件缓存页面</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        // 1. 将缓存 name 为 test 的组件<br>        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><br>        // 2. 将缓存 name 为 a 或者 b 的组件，结合动态组件使用<br>        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;a,b&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><br>        // 3. 使用正则表达式，需使用 v-bind<br>        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;/a|b/&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><br>        // 5.动态判断<br>        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;includedComponents&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br><br>        // 5. 将不缓存 name 为 test 的组件<br>        <span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">exclude</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueX</title>
    <link href="/2021/12/27/VueX/"/>
    <url>/2021/12/27/VueX/</url>
    
    <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><blockquote><p>Vuex 是一个专为 Vue 开发的应用程序的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><p>简而言之，Vuex 采用<strong>类似全局对象</strong>的形式来管理所有组件的公用数据，如果想修改这个全局对象的数据，得按照 Vuex 提供的方式来修改（不能自己随意用自己的方式来修改）</p><h2 id="1-安装和使用"><a href="#1-安装和使用" class="headerlink" title="1 安装和使用"></a>1 安装和使用</h2><p><strong>1.安装 Vuex</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js">npm install vuex --save<br></code></pre></td></tr></table></figure><p><strong>2.引用 Vuex</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>);<br><span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p><strong>3.创建仓库 Store</strong></p><p>要使用 Vuex，我们要创建一个实例 <code>store</code>，我们称之为仓库，利用这个仓库 <code>store</code> 来对我们的状态进行管理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建一个 store</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;&#125;);<br></code></pre></td></tr></table></figure><h2 id="2-单界面的状态管理"><a href="#2-单界面的状态管理" class="headerlink" title="2 单界面的状态管理"></a>2 单界面的状态管理</h2><p><img src="https://img-blog.csdnimg.cn/20200926145610255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="单界面的状态管理"></p><ul><li><strong>State</strong>：不用多说，就是我们的状态。（你姑且可以当做就是 data 中的属性）</li><li><strong>View</strong>：视图层，可以针对 State 的变化，显示不同的信息。</li><li><strong>Actions</strong>：这里的 Actions 主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li></ul><h2 id="3-单界面的状态管理的代码实现"><a href="#3-单界面的状态管理的代码实现" class="headerlink" title="3 单界面的状态管理的代码实现"></a>3 单界面的状态管理的代码实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>当前计数：&#123;&#123;counter&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter+=1&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;counter-=1&quot;</span>&gt;</span>-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span>,</span><br><span class="language-javascript">            &#125;;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><strong>在这个案例中， 我们有个 counter 需要管理</strong></li><li><strong>counter 需要被某种方式被记录下来，也就是我们的</strong> <code>State</code></li><li><strong>counter 目前的值会显示在界面上， 也就是我们的 <code>View</code> 部分</strong></li><li><strong>界面发送某些操作时， 比如我们这里使用的是 点击事件 ， 需要去更新状态， 也就是我们的</strong> <code>Actions</code></li></ol><h2 id="4-Vuex-的核心概念和-API"><a href="#4-Vuex-的核心概念和-API" class="headerlink" title="4 Vuex 的核心概念和 API"></a>4 Vuex 的核心概念和 API</h2><blockquote><p>主要理解实例中下面这些对象是如何运作的。</p></blockquote><p><strong>流程：View -&gt; Actions -&gt; Mutations -&gt; State -&gt; View</strong></p><p><img src="https://img-blog.csdnimg.cn/20200926145610303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="Vuex的核心概念"></p><h3 id="1、-state"><a href="#1、-state" class="headerlink" title="1、 state"></a>1、 state</h3><ol><li><p>vuex 管理的状态对象</p></li><li><p>它应该是唯一的<br>const state &#x3D; {<br>xxx: initValue<br>}</p></li></ol><h3 id="2、-mutations"><a href="#2、-mutations" class="headerlink" title="2、 mutations"></a>2、 mutations</h3><p>​ 1) 包含多个直接更新 state 的方法(回调函数)的对象<br>​ 2) 谁来触发: <strong>action 中的 commit(‘mutation 名称’)</strong><br>​ 3) <strong>只能包含同步的代码, 不能写异步代码</strong><br>​ const mutations &#x3D; {<br>​ yyy (state, {data1}) {<br>​ &#x2F;&#x2F; 更新 state 的某个属性<br>​ }<br>​ }</p><h3 id="3、-actions"><a href="#3、-actions" class="headerlink" title="3、 actions"></a>3、 actions</h3><ol><li><p>包含多个事件回调函数的</p></li><li><p>通过执行: commit()来触发 mutation 的调用, 间接更新 state</p></li><li><p>谁来触发: 组件中: <strong>$store.dispatch(‘action 名称’, data1) &#x2F;&#x2F; ‘zzz</strong></p></li><li><p><strong>可以包含异步代码(axios)</strong></p></li></ol><p>const actions &#x3D;{</p><p>zzz ({commit, state}, data1)</p><p>​ commit(‘yyy’, {data1})</p><p>}</p><p>}</p><h3 id="4、-getters"><a href="#4、-getters" class="headerlink" title="4、 getters"></a>4、 getters</h3><ol><li><p><strong>包含多个计算属性(get)的对象</strong>（也就是说，getters 是用来放 state 里面的变量的计算属性的）</p></li><li><p>谁来读取: 组件中: <strong>$store.getters.xxx</strong></p><p> const getters &#x3D;{</p><p> xxx(state) {</p></li></ol><p>​ return …</p><p>​ }</p><p>}</p><h3 id="5、-modules"><a href="#5、-modules" class="headerlink" title="5、 modules"></a>5、 modules</h3><ol><li><p>包含多个 module</p></li><li><p>一个 module 是一个 store 的配置对象</p></li><li><p>与一个组件(包含有共享数据)对应</p></li></ol><h2 id="5-Vuex-的运作流程"><a href="#5-Vuex-的运作流程" class="headerlink" title="5 Vuex 的运作流程"></a>5 Vuex 的运作流程</h2><h3 id="Vuex-的运作流程"><a href="#Vuex-的运作流程" class="headerlink" title="Vuex 的运作流程"></a>Vuex 的运作流程</h3><p><img src="https://img-blog.csdnimg.cn/20181227125005140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjQ3OTk5,size_16,color_FFFFFF,t_70" alt="Vuex的运作流程"></p><h3 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h3><p>① 在组件（页面）中，通过 dispatch()或 mapActions()这个函数分发给 actions 的函数去处理。</p><p>② actions 的函数可以与后台交互，也可以通过 commit() 提交给 mutations 去处理。</p><p>③ mutations 可以直接与 devtool（如本地存储工具 → 在实例代码中的 utils 里的 storageUtils.js）交互与直接更新 state（数据状态）。</p><p>④ 如果有计算属性（get 函数写在 getters 里面），则状态通过 getters 的$store.getters()或**mapGetters()<strong>来更新组件；反之就通过$store.state()或者</strong>mapState()**的方式来更新组件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中的插槽</title>
    <link href="/2021/12/26/vue%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD/"/>
    <url>/2021/12/26/vue%E4%B8%AD%E7%9A%84%E6%8F%92%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h1><p><img src="https://i.loli.net/2020/09/25/9Zuw71bqsycSd8H.png" alt="image-20200922160708539"></p><p><strong>根据以上图片代码， 可知 最后渲染出来的是 使用 Vue 实例的属性</strong></p><p>结论：</p><ul><li>官方给出了一条准则：<strong>父组件模板的所有东西都会在父级作用域内编译</strong>， <strong>子组件模板的所有东西都会在子级作用域内编译</strong></li><li>而我们在使用<my-cpn v-show="isShow"></my-cpn>的时候，整个组件的使用过程是相当于在父组件中出现的。</li><li>那么他的作用域就是父组件，使用的属性也是属于父组件的属性。</li><li>因此，isShow 使用的是 Vue 实例中的属性，而不是子组件的属性。</li></ul><h1 id="solt-插槽的基本使用"><a href="#solt-插槽的基本使用" class="headerlink" title="solt 插槽的基本使用"></a>solt 插槽的基本使用</h1><p><img src="https://i.loli.net/2020/09/25/miSdjr5DNvCsH2O.png" alt="image-20200922161624398"></p><h2 id="1-具名插槽"><a href="#1-具名插槽" class="headerlink" title="1 具名插槽"></a>1 具名插槽</h2><ul><li>当子组件的功能复杂时，子组件的插槽可能并非是一个。<ul><li>比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。</li><li>那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？</li><li>这个时候，我们就需要给插槽起一个名字</li></ul></li><li>如何使用具名插槽呢？<ul><li>非常简单，只要给 slot 元素一个 name 属性即可</li><li><slot name='myslot'></slot></li></ul></li></ul><p><img src="https://i.loli.net/2020/09/25/R12MJtQkvG5TErA.png" alt="image-20200922161821227"></p><h2 id="2-作用域插槽"><a href="#2-作用域插槽" class="headerlink" title="2 作用域插槽"></a>2 作用域插槽</h2><blockquote><p>因为编译作用域的关系， 各个组件只能使用自己组件内的数据， 如果 父组件 使用插槽 想把子组件数据一并一起拿过来用怎么办？ 这时候就需要用 作用域插槽了</p></blockquote><p><strong>简单一句话：作用域插槽就是：父组件替换插槽的标签，但是内容（数据）是由子组件来提供。</strong></p><ul><li><strong>1.子组件 插槽 slot 动态绑定 把 data 中的 <code>数据</code></strong></li></ul><p><img src="https://i.loli.net/2020/09/25/EUPKAL7rYBFXZve.png" alt="image-20200922163245338"></p><ul><li>2.<strong>父组件使用我们的子组件时，从子组件中拿到数据：</strong><ul><li><strong>我们通过<template slot-scope="slotProps">获取到 slotProps 属性</strong></li><li><strong>在通过 slotProps.data 就可以获取到刚才我们传入的 data 了</strong></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中computed和watch的异同</title>
    <link href="/2021/12/26/vue%E4%B8%AD%E7%9A%84compued%E5%92%8Cwatch/"/>
    <url>/2021/12/26/vue%E4%B8%AD%E7%9A%84compued%E5%92%8Cwatch/</url>
    
    <content type="html"><![CDATA[<h2 id="computed-的作用及写法"><a href="#computed-的作用及写法" class="headerlink" title="computed 的作用及写法"></a>computed 的作用及写法</h2><ul><li><p>写法：<code>&#123; [key: string]: Function | &#123; get: Function, set: Function &#125; &#125;</code></p></li><li><p>用途：被计算出来的属性就是计算属性</p></li><li><p>示例：</p><ul><li><a href="https://codesandbox.io/s/compassionate-lake-xyjkw">用户名展示</a></li><li><a href="https://codesandbox.io/s/bold-matsumoto-efn0i">列表展示</a></li></ul></li><li><p>特点：</p><ul><li><strong>计算属性具有缓存</strong>。计算属性是基于它们的<strong>依赖</strong>进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要<strong>依赖值</strong>都没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。</li></ul></li></ul><h2 id="watch-的作用及写法"><a href="#watch-的作用及写法" class="headerlink" title="watch 的作用及写法"></a>watch 的作用及写法</h2><ul><li><p>写法：</p><ul><li>语法一</li></ul><p>watch {</p><p><del>o1:()&#x3D;&gt;{},</del>(this 指向不对，不建议使用)</p><p>o2:function(value,oldvalue){},</p><p>o3(){},</p><p>o4[fn1,fn2],</p><p>o5:’methodName’,</p><p>o6:{</p><p>Handler:fn,deep:true,immediate:true</p><p>}</p><p>‘object.a’:function(){}</p><p>}</p><ul><li>语法二<ul><li>vm.$watch(‘xxx’,fn,{deep:…,immediate:…})</li><li>‘XXX’可以改成返回字符串的函数</li></ul></li></ul></li><li><p>用途：一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个 property。</p></li><li><p>示例：</p><ul><li><a href="https://codesandbox.io/s/lucid-shamir-cpcw3">撤销</a>（此例说明 watch 是异步的）</li><li><a href="https://codesandbox.io/s/objective-star-vu2h3">模拟 computed</a></li></ul></li><li><p>特点：</p><ul><li>不要使用箭头函数，this 的指向不是期望的</li><li>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调</li><li>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code>。注意监听数组的变更不需要这么做。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue两个版本的之间的区别</title>
    <link href="/2021/12/20/Vue%E4%B8%A4%E7%A7%8D%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/12/20/Vue%E4%B8%A4%E7%A7%8D%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="完整版-VS-非完整版"><a href="#完整版-VS-非完整版" class="headerlink" title="完整版 VS 非完整版"></a>完整版 VS 非完整版</h2><p>Vue 可以分为两个版本：完整版和非完整版，使用比如<a href="https://www.bootcdn.cn/vue/">BootCDN</a>进行引入时可以对比后缀名，带 runtime 的就是非完整版，反之不带的就是完整版，比如：</p><ul><li><code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.js&quot;&gt;&lt;/script&gt;</code> 这是引入了一个完整版</li><li><code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.9/vue.runtime.js&quot;&gt;&lt;/script&gt;</code> 这是引入了一个非完整版（runtime 版）</li></ul><p>他们之间的区别可以参考下表进行对比：<img src="/img/pic26.png" alt="pic26"></p><p>可以看出，他们的主要区别是是否带有<code>complier</code>,因此决定将视图的 html 写在哪，如果使用完整版，那就可以把操作元素写在 html 或者是 Vue 实例的 template 里面，如果使用 runtime 版本，前面的方式就行不通了，只能写在实例的 render 函数里用 h 来创建标签，或者写在 vue 单文件的 template 标签内，这时候就会使用<code>vue-loader</code>来把 vue 文件的 html 转成 h 函数。</p><p>所以一般会倾向于选择非完整版，原因如下：</p><ol><li>保证用户体验，用户下载的 JS 文件体积更小，虽然<strong>只支持 h 函数</strong>。</li><li>保证开发体验，开发者可直接在 vue 文件里写 HTML 标签，而<strong>不写 h 函数</strong>。</li><li>脏活让 loader 做，<strong>vue-loader 把 vue 文件里的 HTML 转为 h 函数</strong>。</li></ol><p>非完整版也是有一个缺点的，即可能造成 SEO 不友好，对应的优化方式就是把 title、description、keyword、h1、a 提前写入页面，让搜索引擎能够看到即可。</p><h2 id="template-与-render-的使用"><a href="#template-与-render-的使用" class="headerlink" title="template 与 render 的使用"></a>template 与 render 的使用</h2><p>1.完整版 template, 引入 vue.js</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div @click=&quot;add&quot;&gt;</span><br><span class="hljs-string">      &#123;&#123;n&#125;&#125;</span><br><span class="hljs-string">      &lt;button&gt; +1 &lt;/button&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">n</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> += <span class="hljs-number">1</span>;<br>        &#125;,<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>2.非完整版 render, 引入 vue.runtime.js 运行时版本<br>使用 vue-cli 创建的目录默认会使用这个 vue.runtime.js</p><p>用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。<br>这种方式不能直接从 HTML 页面里面获取数据，需要使用 render 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) &#123;<br>        <span class="hljs-comment">// vue 会给 render 传一个参数这个参数是一个可以创建html的函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, [<span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>, <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;button&#x27;</span>, &#123; <span class="hljs-attr">on</span>: &#123; <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">add</span> &#125; &#125;, <span class="hljs-string">&#x27;+1&#x27;</span>)]);<br>    &#125;,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">n</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> += <span class="hljs-number">1</span>;<br>        &#125;,<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>这种方式更加的灵活独立，因为运行时版本相比完整版体积要小大约 30%，这样用户在使用产品时就会效果更好，所以应该尽可能使用这个版本。<br>但是这种使用 render 函数的方式显得很麻烦,因此 webpack 提供了 vue-loader<br>当使用 vue-loader 或 vueify 的时候，*.vue 文件内部的模板会在构建时预编译成 JavaScript。你在最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可。</p><p>vue-loader 可以把 html 模板编译成 render 函数的 js 代码，这样在我们最后 build 的时候就会产生一个运行时的版本，从而使体积最小</p><p>只需要写成.vue 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  demo.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;&#123; n &#125;&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">n</span>:<span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>++</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-selector-class">.red</span>&#123;</span></span><br><span class="language-css"><span class="language-xml">    <span class="hljs-attribute">color</span>: red;</span></span><br><span class="language-css"><span class="language-xml">  &#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>vue-loader 会把这个 demo.vue 文件变成一个对象 使用 render 函数渲染这个对象即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(demo);<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="利用-codesandbox-快速创建-Vue"><a href="#利用-codesandbox-快速创建-Vue" class="headerlink" title="利用 codesandbox 快速创建 Vue"></a>利用 codesandbox 快速创建 Vue</h2><p>1.打开<a href="https://codesandbox.io/">CodeSandbox: Online Code Editor and IDE for Rapid Web Development</a>，建议不登陆使用（登陆后会有限制）</p><p>2.点击 create Sandbox 选择 Vue</p><p>3.需要导出文件直接点击下载即可,选择 Export to ZIP</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中.sync修饰符的理解</title>
    <link href="/2021/12/20/Vue%E4%B8%AD%E7%9A%84.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2021/12/20/Vue%E4%B8%AD%E7%9A%84.sync%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要使用-sync"><a href="#为什么需要使用-sync" class="headerlink" title="为什么需要使用.sync"></a>为什么需要使用.sync</h2><p>首先可以参考<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6">官方文档对于.sync 的解释</a>，简单来说，就是因为子组件无法直接修改父组件传入的 prop，如果直接修改，Vue 会弹出一个警告，而且实际运行的效果也不是我们期望的，这时候就需要有一个办法来让我们能够实现子组件修改父组件传入的参数，这里可以使用之前跨对象通行的办法，用 Vue 自带的 EventBus 来解决这个问题。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;bar&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-comp</span> <span class="hljs-attr">:foo.sync</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-comp</span>&gt;</span></span><br>    &lt;!-- <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-comp</span> <span class="hljs-attr">:foo</span>=<span class="hljs-string">&quot;bar&quot;</span> <span class="hljs-attr">v-on:update:foo</span>=<span class="hljs-string">&quot;bar=@event&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-comp</span>&gt;</span></span> --&gt;<br>&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-comp&#x27;</span>, &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div @click=&quot;increment&quot;&gt;点我+1&lt;/div&gt;&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">data</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">copyFoo</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;foo&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:foo&#x27;</span>, ++<span class="hljs-variable language_">this</span>.<span class="hljs-property">copyFoo</span>); <span class="hljs-comment">//发布自定义事件</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">data</span>: &#123;<span class="hljs-attr">bar</span>: <span class="hljs-number">0</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>以上就是一个使用<code>.sync</code>实现子组建修改父组件传入参数的例子，在这个例子里需要注意几点：</p><ul><li>子组建采用<code>this.$emit（）</code>发布自定义事件，第一个参数为自定义事件名，格式必须为： <code>update：propname</code>，第二个参数为传入参数。</li><li><code> &lt;my-comp :foo=&quot;bar&quot; v-on:update:foo=&quot;bar=@event&quot;&gt;&lt;/my-comp&gt;</code>中的<code>@event</code>即为子组件自定义事件第二个传入的参数，这里的@event 不用加<code>this</code></li><li><code>&lt;my-comp :foo.sync=&quot;bar&quot;&gt;&lt;/my-comp&gt;</code>其实就是<code> &lt;my-comp :foo=&quot;bar&quot; v-on:update:foo=&quot;bar=@event&quot;&gt;&lt;/my-comp&gt;</code>的简写，也就是所谓的语法糖，表达的含义是完全相同的</li></ul><p>以上就是对<code>.sync</code>的功能用法的简单讲解,在 Vue3 中我们可以是使用 v-model 来实现类似功能。</p><h2 id="vue2-中-v-model-实现-sync"><a href="#vue2-中-v-model-实现-sync" class="headerlink" title="vue2 中 v-model 实现.sync"></a>vue2 中 v-model 实现.sync</h2><p><code>v-model</code>是 Vue2 中唯一支持双向绑定的指令，用于表单控件绑定，但不代表它只能用在表单控件之上。在文档 <a href="https://link.jianshu.com/?t=https://cn.vuejs.org/v2/guide/components.html%23%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%84%E4%BB%B6%23%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%84%E4%BB%B6">使用自定义事件的表单输入组件</a> 一节中提到了，<code>v-model</code>其实是个语法糖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input v-model=<span class="hljs-string">&quot;something&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这不过是以下示例的语法糖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input v-<span class="hljs-attr">bind</span>:value=<span class="hljs-string">&quot;something&quot;</span>  v-<span class="hljs-attr">on</span>:input=<span class="hljs-string">&quot;something = $event.target.value&quot;</span>&gt;<br><span class="hljs-comment">//简写：&lt;input :value=&quot;something&quot;  @input=&quot;something = $event.target.value&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>也就是说，你只需要在组件中声明一个 name 为 value 的 props，并且通过触发 input 事件传入一个值，就能修改这个 value。改写示例如下：</p><div id="app">    <div></div>    <my-comp v-model="bar"></my-comp>    <!-- <my-comp :foo="bar" v-on:update:foo="bar=@event"></my-comp> --></div><script>    Vue.component('my-comp', {        template: '<div @click="handleInput">点我+1</div>',        data: function() {            return {copyValue: this.value}        },        props: ['value'],        methods: {            handleInput: function() {                this.$emit('input', ++this.copyValue); //发布自定义事件            }        }    });    new Vue({        el: '#app',        data: {bar: 0}    });</script><h2 id="vue3-中-v-model-实现-sync"><a href="#vue3-中-v-model-实现-sync" class="headerlink" title="vue3 中 v-model 实现.sync"></a>vue3 中 v-model 实现.sync</h2><p>先见此篇：<a href="https://v3.cn.vuejs.org/guide/migration/v-model.html#%E6%A6%82%E8%A7%88">v-model | Vue.js (vuejs.org)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack入门配置总结</title>
    <link href="/2021/12/18/webpack%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2021/12/18/webpack%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的配置版本号如下:</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;css-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.2.0&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;dart-sass&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.23.7&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;file-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.2&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;html-webpack-plugin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.2.0&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;less&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.10.3&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;less-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.0&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;mini-css-extract-plugin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^0.8.0&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;sass-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.0&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;style-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.1&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.41.2&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;webpack-cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.3.10&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;webpack-dev-server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.9.0&quot;</span><br> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><blockquote><p>参考文档：webpack 官方文档 , 在配置每一部分时候我会把链接发在里面</p></blockquote><h2 id="package-json-中配置-build"><a href="#package-json-中配置-build" class="headerlink" title="package.json 中配置 build"></a>package.json 中配置 build</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm -rf dist &amp;&amp; webpack&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h2 id="初始化-webpack-config-js"><a href="#初始化-webpack-config-js" class="headerlink" title="初始化 webpack.config.js"></a>初始化 webpack.config.js</h2><h3 id="模式的区别："><a href="#模式的区别：" class="headerlink" title="模式的区别："></a>模式的区别：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-comment">// 开发者模式  注意去观察 dist/main.js  会发现有许多注释并没有被压缩</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-comment">// 生产模式  去观察 dist/main.js  代码都被压缩了，</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="入口文件和出口文件配置："><a href="#入口文件和出口文件配置：" class="headerlink" title="入口文件和出口文件配置："></a>入口文件和出口文件配置：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>, <span class="hljs-comment">// 开发者模式</span><br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>, <span class="hljs-comment">// 打包的入口文件</span><br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 可用不用写，默认是dist文件</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.[contenthash].js&#x27;</span>, <span class="hljs-comment">// 打包出口文件名， 以 index.20位随机数/字母.js以文件名</span><br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="webpack-插件自动生成-HTML："><a href="#webpack-插件自动生成-HTML：" class="headerlink" title="webpack 插件自动生成 HTML："></a>webpack 插件自动生成 HTML：</h2><blockquote><p>webpack 文档链接 ：<a href="https://webpack.js.org/plugins/html-webpack-plugin/">https://webpack.js.org/plugins/html-webpack-plugin/</a> 和 <a href="https://github.com/jantimon/html-webpack-plugin#options">https://github.com/jantimon/html-webpack-plugin#options</a></p></blockquote><p>这样就会在 dist 文件中生成一个 index.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev html-webpack-plugin<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>()],<br>&#125;;<br></code></pre></td></tr></table></figure><p>配置内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>        <span class="hljs-comment">// 可以不写filename这个属性，也默认生成index.html</span><br>        <span class="hljs-comment">// 在这里配置title 要在template中的html文件内的title标签配置 &lt;%= htmlWebpackPlugin.options.title %&gt;</span><br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Wang-pf&#x27;</span>,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;src/assets/index.html&#x27;</span>, <span class="hljs-comment">// 生成模板是哪个</span><br>    &#125;),<br>];<br></code></pre></td></tr></table></figure><h2 id="webpack-引入-CSS："><a href="#webpack-引入-CSS：" class="headerlink" title="webpack 引入 CSS："></a>webpack 引入 CSS：</h2><h3 id="方法一：-用-JS-来生成-style"><a href="#方法一：-用-JS-来生成-style" class="headerlink" title="方法一： 用 JS 来生成 style"></a>方法一： 用 JS 来生成 style</h3><blockquote><p>webpack 文档链接: <a href="https://webpack.docschina.org/loaders/css-loader/#getting-started">https://webpack.docschina.org/loaders/css-loader/#getting-started</a></p></blockquote><p>先安装依赖插件， 必须要安装 style-loader 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev  style-loader css-loader<br></code></pre></td></tr></table></figure><p><strong>原理是 webpack 默认要把 以.css 结尾的放到 style 标签中。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">module</span>: &#123;<br>   <span class="hljs-attr">rules</span>: [&#123;<br>     <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>, <span class="hljs-comment">// 以 .css 结尾的</span><br>     <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>], <span class="hljs-comment">// 依赖插件</span><br><br>  &#125;, ],<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="方法二：-把-CSS-抽成文件"><a href="#方法二：-把-CSS-抽成文件" class="headerlink" title="方法二： 把 CSS 抽成文件"></a>方法二： 把 CSS 抽成文件</h3><p>先安装依赖，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev mini-css-extract-plugin<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">plugins</span>: [<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;<br>            <span class="hljs-comment">// 类似于 webpackOptions.output 中的选项</span><br>            <span class="hljs-comment">// 所有选项都是可选的</span><br>            <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].[contenthash].css&#x27;</span>,<br>            <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[id].[contenthash].css&#x27;</span>,<br>            <span class="hljs-attr">ignoreOrder</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 忽略有关顺序冲突的警告</span><br>        &#125;),<br>    ],<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>                <span class="hljs-attr">use</span>: [<br>                    &#123;<br>                        <span class="hljs-attr">loader</span>: <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,<br>                        <span class="hljs-attr">options</span>: &#123;<br>                            <span class="hljs-comment">// 你可以在这里指定特定的 publicPath</span><br>                            <span class="hljs-comment">// 默认情况下使用 webpackOptions.output 中的 publicPath</span><br>                            <span class="hljs-attr">publicPath</span>: <span class="hljs-string">&#x27;../&#x27;</span>,<br>                        &#125;,<br>                    &#125;,<br>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>                ],<br>            &#125;,<br>        ],<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="webpack-dev-server-的使用"><a href="#webpack-dev-server-的使用" class="headerlink" title="webpack dev-server 的使用"></a>webpack dev-server 的使用</h2><blockquote><p>webpack dev-server 文档链接：<a href="https://www.webpackjs.com/guides/development/">https://www.webpackjs.com/guides/development/</a></p></blockquote><ol><li>安装插件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev webpack-dev-server<br></code></pre></td></tr></table></figure><ol start="2"><li>webpack.config.js 配置</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>: &#123;<br><span class="hljs-attr">contentBase</span>: <span class="hljs-string">&#x27;./dist&#x27;</span><br>&#125;,<br></code></pre></td></tr></table></figure><ol start="3"><li>在 package.json 配置以下 start</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open&quot;</span>,<br></code></pre></td></tr></table></figure><p>在 npm start 的时候发现 报错， 报错原因是：<a href="https://stackoverflow.com/questions/59611597/error-cannot-find-module-webpack-cli-bin-config-yargs">Error: Cannot find module ‘webpack-cli&#x2F;bin&#x2F;config-yargs’</a></p><p>解决方法是：把版本号改一下 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;webpack&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.41.2&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;webpack-cli&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.3.10&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;webpack-dev-server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.9.0&quot;</span><br></code></pre></td></tr></table></figure><h2 id="不同模式使用不同的-webpack-config"><a href="#不同模式使用不同的-webpack-config" class="headerlink" title="不同模式使用不同的 webpack config"></a>不同模式使用不同的 webpack config</h2><blockquote><p>我们已经知道模式有 开发者模式(development) 和 生产模式(production) ,那么我们应该在不同模式中选用不同的插件来使用。</p><p>比如： 在生产模式 production 中，引入 CSS 方法使用 style， 因为这样不同生成一个 CSS 文件，使得效率变高。如果是开发者模式 ，那么我们就需要把 CSS 抽成文件。</p></blockquote><p>创建一个 webpack 配置文件：webpack.config.prod.js 用在生产模式时使用。</p><p>创建一个 webpack 配置文件： webpack.config.base.js 用于开发和生产模式的共同属性</p><p>并在 package.json 文件中重新配置 build。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm -rf dist &amp;&amp; webpack --config webpack.config.prod.js&quot;</span><br></code></pre></td></tr></table></figure><h2 id="webpack-loader-和-webpack-plugin-的区别"><a href="#webpack-loader-和-webpack-plugin-的区别" class="headerlink" title="webpack loader 和 webpack plugin 的区别"></a>webpack loader 和 webpack plugin 的区别</h2><ul><li>loader （加载器） ： 用于加载某些文件，比如加载 JS 文件，可以把 JS 转换为低版本支持的 js, 又比如 CSS,使用相应的 loder 加载，可以把 CSS 放到页面上 style 标签中或者其他处理。也可以用来加载图片，可以对图片进行优化。</li><li>plugin （插件）： 扩展 webpack 功能的，比如使用 HtmlWebpackPlugin 插件用来生成 html 文件， 使用 miniCssExtractPlugin 插件用来生成 CSS 文件等。</li></ul><h2 id="引入-sass"><a href="#引入-sass" class="headerlink" title="引入 sass"></a>引入 sass</h2><blockquote><p>参考链接：<a href="https://webpack.docschina.org/loaders/sass-loader/">https://webpack.docschina.org/loaders/sass-loader/</a></p></blockquote><p>这里使用 datr-sass 不使用 node-sass（已过时）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install sass-loader dart-sass --save-dev<br></code></pre></td></tr></table></figure><p>webpakc.config 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">rules</span>: [&#123;<br>     <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/i</span>,<br>     <span class="hljs-attr">use</span>: [<br>       <span class="hljs-string">&quot;style-loader&quot;</span>,<br>       <span class="hljs-string">&quot;css-loader&quot;</span>,<br>       &#123;<br>         <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;sass-loader&quot;</span>,<br>         <span class="hljs-attr">options</span>: &#123;<br>           <span class="hljs-comment">// `dart-sass` 是首选</span><br>           <span class="hljs-attr">implementation</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dart-sass&quot;</span>),<br>         &#125;,<br>       &#125;,<br>     ],<br>&#125;, ],<br></code></pre></td></tr></table></figure><p>把 css 文件改为 scss 文件即可使用。</p><h2 id="引入-less"><a href="#引入-less" class="headerlink" title="引入 less"></a>引入 less</h2><blockquote><p>文档链接：<a href="https://webpack.js.org/loaders/less-loader/">https://webpack.js.org/loaders/less-loader/</a></p></blockquote><p>安装 loader</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install less less-loader --save-dev<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,<br>    <span class="hljs-attr">loader</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>,<span class="hljs-string">&quot;css-loader&quot;</span>,<span class="hljs-string">&quot;less-loader&quot;</span>], <span class="hljs-comment">// compiles Less to CSS</span><br>  &#125;,<br></code></pre></td></tr></table></figure><p>stylus 和 引入 less 方法一致，不再写了。</p><h2 id="使用-file-loader-引入图片"><a href="#使用-file-loader-引入图片" class="headerlink" title="使用 file-loader 引入图片"></a>使用 file-loader 引入图片</h2><blockquote><p>参考文档: <a href="https://webpack.js.org/loaders/file-loader/">https://webpack.js.org/loaders/file-loader/</a></p></blockquote><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install file-loader --save-dev<br></code></pre></td></tr></table></figure><p>我的版本号：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;file-loader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^5.0.2&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>webpack.config 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">module</span>: &#123;<br>        <span class="hljs-attr">rules</span>: [<br>            &#123;<br>                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif)$/i</span>,<br>                <span class="hljs-attr">use</span>: [<br>                    &#123;<br>                        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>                    &#125;,<br>                ],<br>            &#125;,<br>        ],<br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在 html 页面中引入就可以了。</p><h2 id="webpack-impor-懒加载"><a href="#webpack-impor-懒加载" class="headerlink" title="webpack impor() 懒加载"></a>webpack impor() 懒加载</h2><p>不多说看代码</p><p>inedx.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;懒加载&#x27;</span>;<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>);<br>    promise.<span class="hljs-title function_">then</span>(<br>        <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">module</span>.<span class="hljs-property">default</span>;<br>            <span class="hljs-title function_">fn</span>();<br>        &#125;,<br>        <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;懒加载模块加载失败&#x27;</span>);<br>        &#125;<br>    );<br>&#125;;<br><br>div.<span class="hljs-title function_">appendChild</span>(btn);<br></code></pre></td></tr></table></figure><p>lazy.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是懒加载陌客&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面就是如何使用 import() 来实现懒加载</p><p>用 import() 去加载文件 ，然后得到一个 promise ， 在成功之后 使用 module.default() 调用 lazy.js 文件</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP常见状态码及分类</title>
    <link href="/2021/12/11/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%88%86%E7%B1%BB/"/>
    <url>/2021/12/11/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>ES6 语法小结（待完善）</p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>HTTP 状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的 3 位数字代码</p><p>它由 RFC 2616 规范定义的，并得到 <code>RFC 2518</code>、<code>RFC 2817</code>、<code>RFC 2295</code>、<code>RFC 2774</code>与 <code>RFC 4918</code>等规范扩展</p><p>简单来讲，<code>http</code>状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态</p><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><p>状态码第一位数字决定了不同的响应状态，有如下：</p><ul><li>1 表示消息</li><li>2 表示成功</li><li>3 表示重定向</li><li>4 表示请求错误</li><li>5 表示服务器错误</li></ul><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p><p>常见的有：</p><ul><li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级</li></ul><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><p>代表请求已成功被服务器接收、理解、并接受</p><p>常见的有：</p><ul><li>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li><li>201（已创建）：请求成功并且服务器创建了新的资源</li><li>202（已创建）：服务器已经接收请求，但尚未处理</li><li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li><li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li><li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li><li>206（部分内容）：服务器成功处理了部分请求</li></ul><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p><p>常见的有：</p><ul><li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li><li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li><li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p><p>常见的有：</p><ul><li>400（错误请求）： 服务器不理解请求的语法</li><li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403（禁止）： 服务器拒绝请求</li><li>404（未找到）： 服务器找不到请求的网页</li><li>405（方法禁用）： 禁用请求中指定的方法</li><li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li><li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li>408（请求超时）： 服务器等候请求时发生超时</li></ul><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p><p>常见的有：</p><ul><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li><li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul><h2 id="三、适用场景"><a href="#三、适用场景" class="headerlink" title="三、适用场景"></a>三、适用场景</h2><p>下面给出一些状态码的适用场景：</p><ul><li>100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输</li><li>206：一般用来做断点续传，或者是视频文件等大文件的加载</li><li>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名</li><li>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li><li>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li><li>400：参数有误，请求无法被服务器识别</li><li>403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回</li><li>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</li><li>503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503</li><li>504：网关超时</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的三次握手和四次挥手</title>
    <link href="/2021/12/11/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2021/12/11/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-TCP-的-三次握手"><a href="#关于-TCP-的-三次握手" class="headerlink" title="关于 TCP 的 三次握手"></a>关于 TCP 的 三次握手</h2><h3 id="关于-TCP-协议"><a href="#关于-TCP-协议" class="headerlink" title="关于 TCP 协议"></a>关于 TCP 协议</h3><p>TCP（Transmission Control Protocol，传输控制协议） 是一种面向连接的，可靠的，基于字节流的传输层通信协议。</p><p>与之对应的是<strong>UDP</strong>（User Datagram Protocol，用户数据协议），是不可靠的传输层协议。</p><h3 id="关于-TCP-报文"><a href="#关于-TCP-报文" class="headerlink" title="关于 TCP 报文"></a>关于 TCP 报文</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c4304c090c942a3866ef8c51dcce008~tplv-k3u1fbpfcp-watermark.image" alt="tcp报文"></p><p>在了解什么三次握手之前，我们需要知道 TCP 报文的一些知识。</p><ul><li>源端口号</li><li>目的端口号</li><li><strong>ACK</strong> : TCP 协议规定，只有 ACK&#x3D;1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1。</li><li><strong>SYN</strong>(SYNchronization) : 在连接建立时用来同步序号。当 SYN&#x3D;1 而 ACK&#x3D;0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN&#x3D;1 和 ACK&#x3D;1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。</li></ul><h3 id="生活中的例子说明什么是三次握手"><a href="#生活中的例子说明什么是三次握手" class="headerlink" title="生活中的例子说明什么是三次握手"></a>生活中的例子说明什么是三次握手</h3><p>直接给出专业名词确实很难理解，那么就举个生活中的例子：</p><ul><li>小明说: 你好吗?</li><li>小红说：我很好，你呢？</li><li>小明说：我也是！</li></ul><p>这段话中，</p><p><strong>小明和小红</strong> 就分别是 <strong>源端口号</strong> 和 <strong>目的端口号</strong> ，</p><p><strong>你好吗？</strong> 是询问对方的， 所以是 <strong>SYN</strong> ， 而 seq 就可以理解为询问的内容。</p><p><strong>我很好，你呢？</strong> 中 <strong>我很好</strong> 是回应对方的，所以是 <strong>ACK</strong>，而 ack 就可以理解为 回应的内容 ， <strong>你呢?</strong> 是询问对方的， 所以是 <strong>SYN</strong></p><p><strong>我也是！</strong> 同样 回应对方的， 所以是 <strong>ACK</strong></p><p>而这整个流程就是 <strong>三次握手</strong> ！</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f058e1d83c38411692f9af71108fa792~tplv-k3u1fbpfcp-watermark.image" alt="三次握手"></p><h3 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c2f6e2af714eb5834a98d4108b54a9~tplv-k3u1fbpfcp-watermark.image" alt="三次握手流程"><br>这个过程中，分别是：</p><ol><li>客户端发送 SYN &#x3D; 1 的 询问报文给服务器端， seq 是 x， 进入 SYN_SENT 状态</li><li>服务器回应一个 ACK &#x3D;1 , SYN &#x3D;1 的应答 + 询问报文。 应答号 ack 是 x+1 , 询问号 seq 是 y， 进入 SYN_RCVD 状态</li><li>客户端收到后，回应一个 ACK &#x3D; 1 的应答报文， 应答号是 y+1 , 进入 ESTAB-LISHED 状态</li></ol><h3 id="为什么不是俩次握手-或者是-四次握手呢？"><a href="#为什么不是俩次握手-或者是-四次握手呢？" class="headerlink" title="为什么不是俩次握手 或者是 四次握手呢？"></a>为什么不是俩次握手 或者是 四次握手呢？</h3><p>假设如果是 俩次握手的话， 那么客户端发送请求报文 A， 因为网络延迟的原因，服务器没收到， 然后客户端发送第二遍报文 A , 服务器终于收到了然后建立连接等待客户端发送数据， 然后客户端正常发送数据。 但是过了一会 第一次发送的报文 A 也到达了服务器，那么服务器就会再次建立连接等待客户端发送数据，而客户端并不知情，这样就导致 服务器资源的浪费了。</p><p>TCP 作为一种可靠的传输控制协议，其<strong>核心思想</strong>就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。</p><p>所以三次握手能解决的问题，为什么需要画蛇添足呢？</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器端建立 TCP 连接（三次握手）后，客户端请求 HTTP，服务器端响应给他，等到客户端收到响应后。客户端和服务器端会断开 TCP 连接。 而断开 TCP 连接需要经过四次挥手这个流程。</p><p>如下图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff1fdeb63df44b408aa3ca1ea83e7236~tplv-k3u1fbpfcp-watermark.image" alt="四次挥手"></p><ol><li>客户端发送一个 FIN ， 告诉服务器关闭连接</li><li>服务器端发送一个 ACK ，告诉客户端 已经收到。</li><li>然后服务器端通知 其他应用程序关闭连接，等程序关闭后，服务器会发送一个 FIN ，告诉 客户端 我已断开连接</li><li>客户端再发送 一个 ACK 告诉服务器端 收到！</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack简介</title>
    <link href="/2021/12/10/webpac%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/12/10/webpac%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="1-什么是-webpack？"><a href="#1-什么是-webpack？" class="headerlink" title="1 什么是 webpack？"></a>1 什么是 webpack？</h2><ul><li>官方解释： At its core, webpack is a static module bundler for modern JavaScript applications.</li><li>翻译： 从本质上来讲，webpack 是一个现代的 JavaScript 应用的静态<strong>模块打包</strong>工具</li></ul><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3378498490,2105022646&fm=26&gp=0.jpg" alt="img"></p><h3 id="1-1-模块"><a href="#1-1-模块" class="headerlink" title="1.1 模块"></a>1.1 模块</h3><ul><li>前端模块化：</li><li>目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。</li><li>在 ES6 之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。</li><li>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</li><li>而 webpack 其中一个<strong>核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系</strong>。</li><li>而且不仅仅是 JavaScript 文件，我们的 CSS、图片、json 文件等等在 webpack 中都可以被当做模块来使用</li><li>这就是 webpack 中模块化的概念。</li></ul><h3 id="1-2-打包"><a href="#1-2-打包" class="headerlink" title="1.2 打包"></a>1.2 打包</h3><ul><li>就是将 webpack 中的各种资源模块进行打包合并成一个或多个包(Bundle)。</li><li>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将 scss 转成 css，将 ES6 语法转成 ES5 语法，将 TypeScript 转成 JavaScript 等等操作。</li><li>但是打包的操作似乎 grunt&#x2F;gulp 也可以帮助我们完成，它们有什么不同呢？</li></ul><h3 id="1-3-和-grunt-x2F-gulp-的对比"><a href="#1-3-和-grunt-x2F-gulp-的对比" class="headerlink" title="1.3 和 grunt&#x2F;gulp 的对比"></a>1.3 和 grunt&#x2F;gulp 的对比</h3><ul><li><p>grunt&#x2F;gulp 的核心是<strong>Task</strong></p><ul><li>我们可以配置一系列的 task，并且定义 task 要处理的事务（例如 ES6、ts 转化，图片压缩，scss 转成 css）</li><li>之后让 grunt&#x2F;gulp 来依次执行这些 task，而且让整个流程自动化。</li><li>所以 grunt&#x2F;gulp 也被称为前端自动化任务管理工具。</li></ul></li><li><p>什么时候用 grunt&#x2F;gulp 呢？</p><ul><li>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。</li><li>只需要进行简单的合并、压缩，就使用 grunt&#x2F;gulp 即可。</li><li>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的 webpack 了。</li></ul></li><li><p>grunt&#x2F;gulp 和 webpack 有什么不同呢？</p><ul><li>grunt&#x2F;gulp 更加强调的是前端流程的自动化，模块化不是它的核心。</li><li>webpack 更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</li></ul></li></ul><h2 id="2-webpack-的安装"><a href="#2-webpack-的安装" class="headerlink" title="2 webpack 的安装"></a>2 webpack 的安装</h2><ul><li><p>安装 webpack 首先需要安装 Node.js，Node.js 自带了软件包管理工具 npm<br>查看自己的 node 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">node -v<br></code></pre></td></tr></table></figure></li><li><p>全局安装 webpack(这里我先指定版本号 3.6.0，因为 vue cli2 依赖该版本)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install webpack@3.6.0 -g<br></code></pre></td></tr></table></figure></li><li><p>局部安装 webpack</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment"># 在对应目录下执行该命令</span></span><br>npm install webpack@3.6.0  --save-dev<br><span class="hljs-meta">#</span><span class="language-bash"><span class="hljs-comment">#  因为webpack我们项目打包后不需要使用 ， 所以它只是我们开发时的一个工具  --save-dev  是开发时依赖</span></span><br></code></pre></td></tr></table></figure><ul><li><p>全局安装和局部安装的区别</p><ul><li>在终端直接执行的 webpack 命令，使用的是全局安装的 webpack</li><li>当在 packag.json 中定义了 scripts 时，其中包含了 webpack 命令，那么使用的是局部 webpack</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;bulid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><br> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-webpack-的配置"><a href="#3-webpack-的配置" class="headerlink" title="3 webpack 的配置"></a>3 webpack 的配置</h2><h3 id="3-1-入口和出口"><a href="#3-1-入口和出口" class="headerlink" title="3.1 入口和出口"></a>3.1 入口和出口</h3><ul><li>如果每次使用 webpack 的命令都需要写上入口和出口作为参数，就很麻烦。</li><li>我们要创建一个 webpack.config.js 文件</li></ul><p><img src="https://i.loli.net/2020/09/25/Pk7tDBJoyAeibQr.png" alt="image-20200922173645764"></p><h3 id="3-2-如何使用局部安装的-webpack"><a href="#3-2-如何使用局部安装的-webpack" class="headerlink" title="3.2 如何使用局部安装的 webpack"></a>3.2 如何使用局部安装的 webpack</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><ul><li>第一步：项目中需要安装自己局部的 webpack<ul><li>这里我们让局部安装 <a href="mailto:&#119;&#x65;&#98;&#x70;&#97;&#99;&#107;&#64;&#51;&#x2e;&#54;&#46;&#x30;">&#119;&#x65;&#98;&#x70;&#97;&#99;&#107;&#64;&#51;&#x2e;&#54;&#46;&#x30;</a> （因为我们要使用 脚手架 2 版本来学习）</li><li>Vue CLI3 中已经升级到 webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。</li></ul></li><li>第二步，通过 node_modules&#x2F;.bin&#x2F;webpack 启动 webpack 打包</li></ul><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><ul><li>但是，每次执行都敲这么一长串有没有觉得不方便呢？<ul><li>OK，我们可以在 package.json 的 scripts 中定义自己的执行脚本。</li></ul></li><li>package.json 中的 scripts 的脚本在执行时，会按照一定的顺序寻找命令对应的位置。<ul><li>首先，会寻找本地的 node_modules&#x2F;.bin 路径中对应的命令。</li><li>如果没有找到，会去全局的环境变量中寻找。</li><li>如何执行我们的 build 指令呢？ <code>npm run bulid</code></li></ul></li><li><img src="https://i.loli.net/2020/09/26/RItGULf3edK1VSc.png" alt="image-20200922174156285"></li></ul><h2 id="4-webpack-loader-加载器"><a href="#4-webpack-loader-加载器" class="headerlink" title="4 webpack-loader 加载器"></a>4 webpack-loader 加载器</h2><blockquote><p><strong>loader 是 webpack 中一个非常核心的概念。</strong></p></blockquote><ul><li><p>webpack 用来做什么呢？</p><ul><li><p>在我们之前的实例中，我们主要是用 webpack 来处理我们写的 js 代码，并且 webpack 会自动处理 js 之间相关的依赖。</p></li><li><p>但是，在开发中我们不仅仅有基本的 js 代码处理，我们也需要加载 css、图片，也包括一些高级的将 ES6 转成 ES5 代码，将</p><p>TypeScript 转成 ES5 代码，将 scss、less 转成 css，将.jsx、.vue 文件转成 js 文件等等。</p></li><li><p>对于 webpack 本身的能力来说，对于这些转化是不支持的。</p></li><li><p>那怎么办呢？给 webpack 扩展对应的 loader 就可以啦。</p></li></ul></li><li><p>loader 使用过程：</p><ul><li>步骤一：通过 npm 安装需要使用的 loader</li><li>步骤二：在 webpack.config.js 中的 modules 关键字下进行配置</li></ul></li><li><p>大部分 loader 我们都可以在 webpack 的官网中找到，并且学习对应的用法。</p></li></ul><p>webpack.config.js 文件如下： <strong>如何配置 响应的 loader 在 module 内</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JSON">const path = require(&#x27;path&#x27;)<br><br>module.exports = <span class="hljs-punctuation">&#123;</span><br>  entry<span class="hljs-punctuation">:</span> &#x27;./src/main.js&#x27;<span class="hljs-punctuation">,</span><br>  output<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    path<span class="hljs-punctuation">:</span> path.resolve(__dirname<span class="hljs-punctuation">,</span> &#x27;dist&#x27;)<span class="hljs-punctuation">,</span><br>    filename<span class="hljs-punctuation">:</span> &#x27;bundle.js&#x27;<span class="hljs-punctuation">,</span><br>    publicPath<span class="hljs-punctuation">:</span> &#x27;dist/&#x27;<br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  module<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    rules<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>        test<span class="hljs-punctuation">:</span> /\.css$/<span class="hljs-punctuation">,</span><br>        <span class="hljs-comment">// style-loader 负责将样式添加到DOM中</span><br>        <span class="hljs-comment">// css-loader 负责将css文件进行加载</span><br>        <span class="hljs-comment">// 注意：  使用多个 loader时， webpack是从右向左解析的</span><br>        use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;style-loader&#x27;<span class="hljs-punctuation">,</span> &#x27;css-loader&#x27;<span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        test<span class="hljs-punctuation">:</span> /\.(png|jpg|gif)$/<span class="hljs-punctuation">,</span><br>        use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>          loader<span class="hljs-punctuation">:</span> &#x27;file-loader&#x27;<span class="hljs-punctuation">,</span><br>          options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            name<span class="hljs-punctuation">:</span> &#x27;img/<span class="hljs-punctuation">[</span>name<span class="hljs-punctuation">]</span>.<span class="hljs-punctuation">[</span>hash<span class="hljs-punctuation">:</span><span class="hljs-number">8</span><span class="hljs-punctuation">]</span>.<span class="hljs-punctuation">[</span>ext<span class="hljs-punctuation">]</span>&#x27;<br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#123;</span><br>        test<span class="hljs-punctuation">:</span> /\.js$/<span class="hljs-punctuation">,</span><br>        exclude<span class="hljs-punctuation">:</span> /(node_modules|bower_components)/<span class="hljs-punctuation">,</span><br>        use<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          loader<span class="hljs-punctuation">:</span> &#x27;babel-loader&#x27;<span class="hljs-punctuation">,</span><br>          options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            presets<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>&#x27;es2015&#x27;<span class="hljs-punctuation">]</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5-webpack-插件-plugin"><a href="#5-webpack-插件-plugin" class="headerlink" title="5 webpack 插件 plugin"></a>5 webpack 插件 plugin</h2><ul><li>plugin 是什么？<ul><li>plugin 是插件的意思，通常是用于对某个现有的架构进行扩展。</li><li>webpack 中的插件，就是对 webpack 现有功能的各种扩展，比如打包优化，文件压缩等等。</li></ul></li><li>loader 和 plugin 区别<ul><li>loader 主要用于转换某些类型的模块，它是一个转换器。</li><li>plugin 是插件，它是对 webpack 本身的扩展，是一个扩展器。</li></ul></li><li>plugin 的使用过程：<ul><li>步骤一：通过 npm 安装需要使用的 plugins(某些 webpack 已经内置的插件不需要安装)</li><li>步骤二：在 webpack.config.js 中的 plugins 中配置插件。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Axios入门</title>
    <link href="/2021/12/06/Axios/"/>
    <url>/2021/12/06/Axios/</url>
    
    <content type="html"><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><blockquote><p>axios: ajax i&#x2F;o system.</p></blockquote><ul><li><p><strong>功能特点</strong> ：</p><ul><li>在浏览器中发送 XMLHttpRequests 请求</li><li>在 node.js 中发送 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li></ul></li><li><p><strong>支持多种请求方式</strong></p><ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul></li></ul><h2 id="get-请求演示"><a href="#get-请求演示" class="headerlink" title="get 请求演示"></a>get 请求演示</h2><p><img src="https://img-blog.csdnimg.cn/20200926145610808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="get 请求演示"></p><h2 id="发送并发请求"><a href="#发送并发请求" class="headerlink" title="发送并发请求"></a>发送并发请求</h2><ul><li>有时候, 我们可能需求同时发送两个请求<ul><li>使用<strong>axios.all,</strong> 可以放入多个请求的数组. res[0],res[1] 得出结果</li><li><strong>axios.all([]) 返回的结果是一个数组</strong>，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200926145610347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="发送并发请求"></p><p>如果不使用 axios.spread 那就 用 最简单的数组方法得出结果： res[0],res[1]</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><blockquote><p>在上面的示例中, 我们的 BaseURL 是固定的<br>事实上, 在开发中可能很多参数都是固定的.<br>这个时候我们可以进行一些抽取, 也可以利用 axiox 的全局配置</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript">axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">baseURL</span> = ‘<span class="hljs-number">123.207</span><span class="hljs-number">.32</span><span class="hljs-number">.32</span>:<span class="hljs-number">8000</span>’axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">headers</span>.<br>post[‘<span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>’] = ‘application/x-www-form-urlencoded’;<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200926145610330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="全局配置"></p><h2 id="创建-axios-实例"><a href="#创建-axios-实例" class="headerlink" title="创建 axios 实例"></a>创建 axios 实例</h2><ul><li>为什么要创建 axios 的实例呢?<ul><li>当我们从 axios 模块中导入对象时, 使用的实例是默认的实例.</li><li>当给该实例设置一些默认配置时, 这些配置就被固定下来了.</li><li>但是后续开发中, 某些配置可能会不太一样.</li><li>比如某些请求需要使用特定的 baseURL 或者 timeout 或者 content-Type 等.</li><li>这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息.</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200926145610848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bmenp6eno=,size_16,color_FFFFFF,t_70#pic_center" alt="创建 axios 实例"></p><h2 id="axios-模块化封装"><a href="#axios-模块化封装" class="headerlink" title="axios 模块化封装"></a>axios 模块化封装</h2><blockquote><p>在实际开发过程中，需要对 AJAX 请求进行统一的封装，使其模块化，易于修改和操作。</p><p>所以，最好这样做，而不是直接在 组件内使用 axios 插件 ，那样后期修改整个 axios 时会及其麻烦</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">//  1.配置基本信息</span><br>    <span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>        <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://152.136.185.210:8000/api/z8&#x27;</span>,<br>        <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>    &#125;);<br>    <span class="hljs-comment">//  本身返回的就一个 Promise   不需要再次封装一个 Promise来使用</span><br>    <span class="hljs-comment">// 3.发送真正的网络请求  ( 方式一)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config);<br>&#125;<br><br><span class="hljs-comment">//  使用 回调函数   ( 方式二)</span><br><br><span class="hljs-comment">// export function request(config, success, failure) &#123;</span><br><br><span class="hljs-comment">//   const instance = axios.create(&#123;</span><br><span class="hljs-comment">//     baseURL: &#x27;http://152.136.185.210:8000/api/z8&#x27;,</span><br><span class="hljs-comment">//     timeout: 5000</span><br><span class="hljs-comment">//   &#125;)</span><br><br><span class="hljs-comment">//   instance(config)</span><br><span class="hljs-comment">//     .then(res =&gt; &#123;</span><br><span class="hljs-comment">//       success(res)</span><br><span class="hljs-comment">//     &#125;)</span><br><span class="hljs-comment">//     .catch(err =&gt; &#123;</span><br><span class="hljs-comment">//       failure(err)</span><br><span class="hljs-comment">//     &#125;)</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 使用 Promise      ( 方式三 )</span><br><span class="hljs-comment">// export function request(config) &#123;</span><br><br><span class="hljs-comment">//   return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="hljs-comment">//     const instance = axios.create(&#123;</span><br><span class="hljs-comment">//       baseURL: &#x27;http://152.136.185.210:8000/api/z8&#x27;,</span><br><span class="hljs-comment">//       timeout: 5000</span><br><span class="hljs-comment">//     &#125;)</span><br><br><span class="hljs-comment">//     instance(config)</span><br><span class="hljs-comment">//       .then(res =&gt; &#123;</span><br><span class="hljs-comment">//         resolve(res)</span><br><span class="hljs-comment">//       &#125;)</span><br><span class="hljs-comment">//       .catch(err =&gt; &#123;</span><br><span class="hljs-comment">//         reject(err)</span><br><span class="hljs-comment">//       &#125;)</span><br><span class="hljs-comment">//   &#125;)</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//  在组件内 传入对象 进行网络请求</span><br><br><span class="hljs-comment">// 方式一和方式三（promise） ，</span><br><span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/home/multidata&#x27;</span>,<br>&#125;)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125;);<br><br><span class="hljs-comment">// 方式二 （使用的回调函数）:</span><br><span class="hljs-title function_">request</span>(<br>    &#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/home/multidata&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><h2 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h2><blockquote><p>axios 提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">//  1.配置基本信息   （创建实例， 这样不是全局的）</span><br>    <span class="hljs-keyword">const</span> instance = axios.<span class="hljs-title function_">create</span>(&#123;<br>        <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://152.136.185.210:8000/api/z8&#x27;</span>,<br>        <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>    &#125;);<br>    <span class="hljs-comment">// 2.axios 拦截器</span><br>    <span class="hljs-comment">// 2.1请求拦截的作用：</span><br>    instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">//  这里可以拦截一些：</span><br>            <span class="hljs-comment">// 1. 比如config中的一些信息不符合服务器的要求</span><br>            <span class="hljs-comment">// 2. 比如每次发送网络请求时，都希望在页面中显示一个请求的图标</span><br>            <span class="hljs-comment">// 3. 某些网络请求（比如登录需要的（token），必须携带一些特殊的信息）</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config);<br>            <span class="hljs-comment">// 拦截后 要发出去  要不就收不到</span><br>            <span class="hljs-keyword">return</span> config;<br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>        &#125;<br>    );<br><br>    <span class="hljs-comment">// 2.2 响应拦截</span><br>    instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 响应的成功拦截中，主要是对数据进行过滤。</span><br>            <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>; <span class="hljs-comment">// 真正有用的东西是 data中的数据</span><br>        &#125;,<br>        <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面。</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>        &#125;<br>    );<br><br>    <span class="hljs-comment">//  本身返回的就一个 Promise   不需要再次封装一个 Promise来使用</span><br>    <span class="hljs-comment">// 3.发送真正的网络请求</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">instance</span>(config);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Axios</tag>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6语法小结（不完全）</title>
    <link href="/2021/12/04/ES6%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/"/>
    <url>/2021/12/04/ES6%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h3><p>都是申明一个变量</p><p>var</p><ul><li>有变量提升</li><li>没有块级作用域</li><li>可以重复声明</li></ul><p>let</p><ul><li>不存在变量提升（暂时性死区）</li><li>有块级作用域</li><li>不可以重复声明</li></ul><p>const</p><ul><li>定义时必须赋值，且值不可以更改</li><li>其余特征与 let 类似</li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</p><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">//2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c); <span class="hljs-comment">//3</span><br><span class="hljs-comment">//如果解构不成功，变量的值为undefined</span><br></code></pre></td></tr></table></figure><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;;<br><span class="hljs-keyword">let</span> &#123; name, age &#125; = person;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 20</span><br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge &#125; = person; <span class="hljs-comment">// myName myAge 属于别名</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myName); <span class="hljs-comment">// &#x27;zhangsan&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myAge); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>这里需要特别注意<code>null</code>与<code>undefined</code>的以及函数参数的解构赋值问题。</p><h3 id="字符串-函数-数组-对象"><a href="#字符串-函数-数组-对象" class="headerlink" title="字符串 函数 数组 对象"></a>字符串 函数 数组 对象</h3><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>ES6 新增的创建字符串的方式，使用反引号定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">`zhangsan`</span>;<br></code></pre></td></tr></table></figure><h5 id="模板字符串中可以解析变量"><a href="#模板字符串中可以解析变量" class="headerlink" title="模板字符串中可以解析变量"></a>模板字符串中可以解析变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;张三&#x27;</span>;<br><span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`hello,my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>; <span class="hljs-comment">// hello, my name is zhangsan</span><br></code></pre></td></tr></table></figure><h5 id="模板字符串中可以换行"><a href="#模板字符串中可以换行" class="headerlink" title="模板字符串中可以换行"></a>模板字符串中可以换行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> html = <span class="hljs-string">` &lt;div&gt;</span><br><span class="hljs-string">     &lt;span&gt;<span class="hljs-subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span><br><span class="hljs-string">     &lt;span&gt;<span class="hljs-subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span><br><span class="hljs-string">     &lt;span&gt;<span class="hljs-subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span><br><span class="hljs-string"> &lt;/div&gt; `</span>;<br></code></pre></td></tr></table></figure><h5 id="在模板字符串中可以调用函数"><a href="#在模板字符串中可以调用函数" class="headerlink" title="在模板字符串中可以调用函数"></a>在模板字符串中可以调用函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sayHello = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;哈哈哈哈 追不到我吧 我就是这么强大&#x27;</span>;<br>&#125;;<br><span class="hljs-keyword">let</span> greet = <span class="hljs-string">`<span class="hljs-subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greet); <span class="hljs-comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span><br></code></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 中新增的定义函数的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">() =&gt; &#123;&#125;; <span class="hljs-comment">//()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;; <span class="hljs-comment">//代表把一个函数赋值给fn</span><br></code></pre></td></tr></table></figure><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>    <span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br><span class="hljs-comment">//es6写法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">num1, num2</span>) =&gt; num1 + num2;<br></code></pre></td></tr></table></figure><p>如果形参只有一个，可以省略小括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">v</span>) &#123;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-comment">//es6写法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">v</span>) =&gt; v;<br></code></pre></td></tr></table></figure><p>箭头函数不绑定 this 关键字，箭头函数中的 this，指向的是函数定义位置的上下文 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span> &#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//this 指向 是obj对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象</span><br>    &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> resFn = fn.<span class="hljs-title function_">call</span>(obj);<br><span class="hljs-title function_">resFn</span>();<br></code></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>箭头函数中不绑定 this，箭头函数中的 this 指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的 this 指向谁，它就指向谁</li><li>箭头函数的优点在于解决了 this 执行环境所造成的一些问题。比如：解决了匿名函数 this 指向的问题（匿名函数的执行环境具有全局性），包括 setTimeout 和 setInterval 中使用 this 所造成的问题</li></ul><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">first, ...args</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// 10</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args); <span class="hljs-comment">// [20, 30]</span><br>&#125;<br><span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><h4 id="剩余参数和解构配合使用"><a href="#剩余参数和解构配合使用" class="headerlink" title="剩余参数和解构配合使用"></a>剩余参数和解构配合使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> students = [<span class="hljs-string">&#x27;wangwu&#x27;</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>];<br><span class="hljs-keyword">let</span> [s1, ...s2] = students;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1); <span class="hljs-comment">// &#x27;wangwu&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s2); <span class="hljs-comment">// [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span><br></code></pre></td></tr></table></figure><h4 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h4><p>将伪数组或可遍历对象转换为真正的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个集合</span><br><span class="hljs-keyword">let</span> arrayLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>,<br>&#125;;<br><span class="hljs-comment">//转成数组</span><br><span class="hljs-keyword">let</span> arr2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>使用 ES6 剩余参数更简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr2 = [...arrayLike];<br></code></pre></td></tr></table></figure><h3 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h3><p>export 用于在 JavaScript 模块中导出函数，原始值，对象；即导出模块。</p><h4 id="export-（命名导出）"><a href="#export-（命名导出）" class="headerlink" title="export （命名导出）"></a>export （命名导出）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123;myFunction&#125;;<span class="hljs-comment">//命名导出函数</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> value=<span class="hljs-number">5</span>;<span class="hljs-comment">//命名导出原始值</span><br><br><span class="hljs-keyword">export</span> &#123;object1, object2, ....&#125;; <span class="hljs-comment">//命名导出对象</span><br></code></pre></td></tr></table></figure><p>命名导出可以导出多个值，但是导入时命名需要与导出命名相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// in module.js</span><br><br><span class="hljs-keyword">let</span> func1=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>....<br><br>&#125;;<br><br><span class="hljs-keyword">let</span> func2=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>...<br><br>&#125;;<br><br><span class="hljs-keyword">export</span> &#123;func1,func2&#125;;<br><br><span class="hljs-comment">// invoke.js</span><br><br><span class="hljs-keyword">import</span> &#123;func1, func2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module.js&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="export-default（默认导出）"><a href="#export-default（默认导出）" class="headerlink" title="export default（默认导出）"></a>export default（默认导出）</h4><p>只能有一个默认导出；导入时，可以使用任意命名导 默认导出的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//module.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> val=<span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//invoke.js</span><br><br><span class="hljs-keyword">import</span> res <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module.js&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="Class-与继承"><a href="#Class-与继承" class="headerlink" title="Class 与继承"></a>Class 与继承</h3><p>JavaScript 语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Point</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>&#125;<br><br><span class="hljs-title class_">Point</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>如果使用 ES6 的语法参考如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    &#125;<br><br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于做了一层包装，即语法糖。</p><p>class 实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, color</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>    &#125;<br><br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 调用父类的toString()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上就是对俩个关键字<code>extends</code>与<code>super</code>的应用，之前博客写过这里不再赘述。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS继承以及优先级</title>
    <link href="/2021/11/28/CSS%E7%BB%A7%E6%89%BF%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2021/11/28/CSS%E7%BB%A7%E6%89%BF%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS-继承属性"><a href="#CSS-继承属性" class="headerlink" title="CSS 继承属性"></a>CSS 继承属性</h2><p><strong>一、无继承性的属性</strong></p><p>1、display：规定元素应该生成的框的类型</p><p>2、文本属性：</p><p>vertical-align：垂直文本对齐</p><p>text-decoration：规定添加到文本的装饰</p><p>text-shadow：文本阴影效果</p><p>white-space：空白符的处理</p><p>unicode-bidi：设置文本的方向</p><p>3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</p><p>4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</p><p>5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</p><p>6、生成内容属性：content、counter-reset、counter-increment</p><p>7、轮廓样式属性：outline-style、outline-width、outline-color、outline</p><p>8、页面样式属性：size、page-break-before、page-break-after</p><p>9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</p><p><strong>二、有继承性的属性</strong></p><p>1、字体系列属性</p><p>font：组合字体</p><p>font-family：规定元素的字体系列</p><p>font-weight：设置字体的粗细</p><p>font-size：设置字体的尺寸</p><p>font-style：定义字体的风格</p><p>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。</p><p>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。</p><p>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</p><p>2、文本系列属性</p><p>text-indent：文本缩进</p><p>text-align：文本水平对齐</p><p>line-height：行高</p><p>word-spacing：增加或减少单词间的空白（即字间隔）</p><p>letter-spacing：增加或减少字符间的空白（字符间距）</p><p>text-transform：控制文本大小写</p><p>direction：规定文本的书写方向</p><p>color：文本颜色</p><p>3、元素可见性：visibility</p><p>4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</p><p>5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style</p><p>6、生成内容属性：quotes</p><p>7、光标属性：cursor</p><p>8、页面样式属性：page、page-break-inside、windows、orphans</p><p>9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation</p><p>三、<strong>所有元素可以继承的属性</strong></p><p>1、元素可见性：visibility</p><p>2、光标属性：cursor</p><p>四、<strong>内联元素可以继承的属性</strong></p><p>1、字体系列属性</p><p>2、除 text-indent、text-align 之外的文本系列属性</p><p>五、<strong>块级元素可以继承的属性</strong></p><p>1、text-indent、text-align</p><h2 id="CSS-优先级"><a href="#CSS-优先级" class="headerlink" title="CSS 优先级"></a>CSS 优先级</h2><h4 id="1-权重计算公式"><a href="#1-权重计算公式" class="headerlink" title="1. 权重计算公式"></a>1. 权重计算公式</h4><p>关于 CSS 权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p><table><thead><tr><th>标签选择器</th><th>计算权重公式</th></tr></thead><tbody><tr><td>继承或者 *</td><td>0,0,0,0</td></tr><tr><td>每个元素（标签选择器）</td><td>0,0,0,1</td></tr><tr><td>每个类，伪类</td><td>0,0,1,0</td></tr><tr><td>每个 ID</td><td>0,1,0,0</td></tr><tr><td>每个行内样式 style&#x3D;””</td><td>1,0,0,0</td></tr><tr><td>每个!important 重要的</td><td>∞ 无穷大</td></tr></tbody></table><ul><li>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</li><li>关于 CSS 权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</li><li><strong>当同一个元素使用了两次 !important 之后还是需要对比选择器的优先级以确定那个会被覆盖。</strong></li></ul><h4 id="2-权重叠加"><a href="#2-权重叠加" class="headerlink" title="2. 权重叠加"></a>2. 权重叠加</h4><p>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p><p>就是一个简单的加法计算</p><ul><li><p>div ul li ——&gt; 0,0,0,3</p></li><li><p>.nav ul li ——&gt; 0,0,1,2</p></li><li><p>a:hover —–—&gt; 0,0,1,1</p></li><li><p>.nav a ——&gt; 0,0,1,1</p><p>注意：</p></li></ul><ol><li>数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 &#x3D;0,0,0,10 而不是 0,0, 1, 0， 所以不会存在 10 个 div 能赶上一个类选择器的情况。</li></ol><h4 id="3-继承的权重是-0"><a href="#3-继承的权重是-0" class="headerlink" title="3. 继承的权重是 0"></a>3. 继承的权重是 0</h4><p>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</p><p>1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。<br>2） 如果没有选中，那么权重是 0，因为继承的权重为 0.</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>promise的理解</title>
    <link href="/2021/11/28/promise%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/11/28/promise%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Promise-的用途"><a href="#Promise-的用途" class="headerlink" title="Promise 的用途"></a>Promise 的用途</h2><p>promise 是异步编程的一种解决方案，promise 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p><h2 id="创建-promise"><a href="#创建-promise" class="headerlink" title="创建 promise"></a>创建 promise</h2><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// ... some code</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Promise-prototype-then-的用法"><a href="#Promise-prototype-then-的用法" class="headerlink" title="Promise.prototype.then() 的用法"></a>Promise.prototype.then() 的用法</h2><p>then()用来执行回调函数，它最多需要有两个参数：Promise 的成功和失败情况的回调函数，并且 then 方法里也可以返回 promise 对象，这样就可以链式调用了。</p><p>语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p.<span class="hljs-title function_">then</span>(onFulfilled[, onRejected]);<br></code></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Pro</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">time</span>) &#123;<br>    <span class="hljs-comment">//返回一个Promise对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;123&#x27;</span>);<br>        <span class="hljs-comment">//模拟接口调用</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-comment">//这里告诉Promise 成功了，然后去执行then方法的第一个函数</span><br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;成功返回&#x27;</span>);<br>        &#125;, time);<br>    &#125;);<br>&#125;;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br>    <span class="hljs-title class_">Pro</span>(<span class="hljs-number">3000</span>)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Pro</span>(<span class="hljs-number">5000</span>);<br>        &#125;)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;end&#x27;</span>);<br>        &#125;);<br>&#125;)();<br><span class="hljs-comment">//依次输出：</span><br><span class="hljs-comment">//start</span><br><span class="hljs-comment">//123</span><br><span class="hljs-comment">//成功返回</span><br><span class="hljs-comment">//123</span><br><span class="hljs-comment">//end</span><br></code></pre></td></tr></table></figure><h2 id="Promise-all-的用法"><a href="#Promise-all-的用法" class="headerlink" title="Promise.all() 的用法"></a>Promise.all() 的用法</h2><p>Promise.all() 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。个 Promise 的 resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束，或者输入的 iterable 里没有 promise 了的时候。它的 reject 回调执行是，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。</p><p>语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(iterable);<br></code></pre></td></tr></table></figure><p>iterable 指可迭代对象，如 Array 等</p><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">results</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success:&#x27;</span> + results);<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r);<br>    &#125;);<br><span class="hljs-comment">//输出：success:1,2,3</span><br></code></pre></td></tr></table></figure><h2 id="Promise-race-的用法"><a href="#Promise-race-的用法" class="headerlink" title="Promise.race() 的用法"></a>Promise.race() 的用法</h2><p>Promise.race() 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝，也就是说取决于最先改变状态的 promise 实例。</p><p>语法与 all 类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(iterable);<br></code></pre></td></tr></table></figure><p>iterable 指可迭代对象，如 Array 等</p><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;one&#x27;</span>);<br>&#125;);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;two&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p1, p2]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// &quot;two&quot;</span><br>    <span class="hljs-comment">// 两个都完成，但 p2 更快</span><br>&#125;);<br><br><span class="hljs-keyword">var</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;three&#x27;</span>);<br>&#125;);<br><span class="hljs-keyword">var</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;four&#x27;</span>);<br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([p3, p4]).<span class="hljs-title function_">then</span>(<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// &quot;three&quot;</span><br>        <span class="hljs-comment">// p3 更快，所以它完成了</span><br>    &#125;,<br>    <span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-comment">// 未被调用</span><br>    &#125;<br>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>call,apply,bind的用法</title>
    <link href="/2021/11/27/call,apply,bind%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2021/11/27/call,apply,bind%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>首先要知道<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">call</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a> 的主要作用都是改变 this 的指向，下面介绍它们的具体区别和使用方法</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call 的写法:<code>Function.call(obj,[param1[,param2[,…[,paramN]]]])</code></p><p>需要注意以下几点：</p><ul><li><p>调用 call 的对象，必须是个函数 Function。</p></li><li><p>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</p></li><li><p>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b, c</span>) &#123;&#125;<br><br>func.<span class="hljs-title function_">call</span>(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// func 接收到的参数实际上是 1,2,3</span><br><br>func.<span class="hljs-title function_">call</span>(obj, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// func 接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply 的写法<code>Function.apply(obj[,argArray])</code></p><p>需要注意的是：</p><ul><li>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</li><li>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间唯一的区别</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">func.<span class="hljs-title function_">apply</span>(obj, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><span class="hljs-comment">// func 接收到的参数实际上是 1,2,3</span><br><br>func.<span class="hljs-title function_">apply</span>(obj, &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>,<br>&#125;);<br><span class="hljs-comment">// func 接收到的参数实际上是 1,2,3</span><br></code></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 的写法：<code>Function.bind(thisArg[, arg1[, arg2[, ...]]])</code></p><p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，<strong>bind 方法的返回值是函数，并且需要稍后调用，才会执行</strong>。而 apply 和 call 则是立即调用。</p><p>来看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br>add.<span class="hljs-title function_">bind</span>(sub, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 这时，并不会返回 8</span><br>add.<span class="hljs-title function_">bind</span>(sub, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)(); <span class="hljs-comment">// 调用后，返回 8</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面可以看到，appl、call、bind 三者的区别在于：</p><ul><li>三者都可以改变函数的 this 对象指向</li><li>三者第一个参数都是 this 要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window</li><li>三者都可以传参，但是 apply 是数组，call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入</li><li>bind 是返回绑定 this 之后的函数，apply 、call 则是立即执行</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同源和跨域</title>
    <link href="/2021/11/27/%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/"/>
    <url>/2021/11/27/%E5%90%8C%E6%BA%90%E4%B8%8E%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="同源与跨域"><a href="#同源与跨域" class="headerlink" title="同源与跨域"></a>同源与跨域</h2><ul><li>源<ul><li>window.orgin 或者 location.origin 可以得到当前源</li><li>源 &#x3D; 协议 + 域名 + 端口</li></ul></li><li>同源<ul><li>协议相同</li><li>域名相同</li><li>端口号相同</li></ul></li><li>同源限制<ul><li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</li><li>无法接触非同源网页的 DOM。</li><li>无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</li></ul></li><li>跨域<ul><li>明确了同源限制之后，就能明白跨域其实就是突破同源限制向非非同源服务器请求数据</li></ul></li></ul><h2 id="JSONP-方法实现跨域"><a href="#JSONP-方法实现跨域" class="headerlink" title="JSONP 方法实现跨域"></a>JSONP 方法实现跨域</h2><p>JSONP 即 JSON WITH PADDING，特点是简单易用，服务器端改造小，没有兼容问题，IE 可以使用。</p><p>它的做法如下。</p><p>第一步，网页添加一个 <code>&lt;script&gt;</code> 元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&#x27;http://api.foo.com?callback=bar&#x27;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>注意，请求的脚本网址有一个 callback 参数（?callback&#x3D;bar），用来告诉服务器，客户端的回调函数名称（bar）。</p><p>第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（bar({…})）。</p><p>第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是 <code>&lt;script&gt;</code> 标签请求的脚本内容。这时，客户端只要定义了 bar() 函数，就能在该函数体内，拿到服务器返回的 JSON 数据。</p><p>下面看一个实例。首先，网页动态插入 <code>&lt;script&gt;</code> 元素，由它向跨域网址发出请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addScriptTag</span>(<span class="hljs-params">src</span>) &#123;<br>    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/javascript&#x27;</span>);<br>    script.<span class="hljs-property">src</span> = src;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br>&#125;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">addScriptTag</span>(<span class="hljs-string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Your public IP address is: &#x27;</span> + data.<span class="hljs-property">ip</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码通过动态添加 <code>&lt;script&gt;</code> 元素，向服务器 example.com 发出请求。注意，该请求的查询字符串有一个 callback 参数，用来指定回调函数的名字，这对于 JSONP 是必需的。</p><p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">foo</span>(&#123;<br>    <span class="hljs-attr">ip</span>: <span class="hljs-string">&#x27;8.8.8.8&#x27;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>由于 <code>&lt;script&gt;</code> 元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了 foo 函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 JSON.parse 的步骤。</p><h2 id="CORS-实现跨域"><a href="#CORS-实现跨域" class="headerlink" title="CORS 实现跨域"></a>CORS 实现跨域</h2><p>CORS 即“跨域资源共享”（Cross-origin resource sharing）,CORS 分为简单请求和非简单请求，方便起见先描述简单请求</p><ul><li>简单请求<ul><li>请求方法：<ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li>HTTP 头信息<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值 application&#x2F;x-www-form-urlencoded 、 multipart&#x2F;form-data、text&#x2F;plain</li></ul></li></ul></li></ul><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是浏览器自动在头信息之中，增加一个 Origin 字段，如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Access</span>-Control-Allow-Origin: http://api.bob.com<br><span class="hljs-keyword">Access</span>-Control-Allow-Credentials: <span class="hljs-keyword">true</span><br><span class="hljs-keyword">Access</span>-Control-Expose-Headers: FooBar<br>Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; charset=utf<span class="hljs-number">-8</span><br></code></pre></td></tr></table></figure><p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p><p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p><p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到 6 个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><ul><li><p>对于复杂请求，则需要在响应端添加其他的的响应头：</p><ul><li><p>响应 OPTIONS 请求，在响应中添加如下的响应头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//甲站点</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>- <span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Methods</span>: <span class="hljs-variable constant_">POST</span>, <span class="hljs-variable constant_">GET</span>, <span class="hljs-variable constant_">OPTIONS</span>, <span class="hljs-variable constant_">PATCH</span><br><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>- <span class="hljs-title class_">Headers</span>: <span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span><br></code></pre></td></tr></table></figure></li><li><p>响应 POST 请求，在响应中添加 <code>Access-Control-Allow-Origin</code> 头。</p></li></ul></li><li><p>如果需要附带身份信息，JS 中需要在 AJAX 里设置<code>xhr.withCredentials=true</code>。</p><p>详情可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组去重的几个办法</title>
    <link href="/2021/11/27/%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8A%9E%E6%B3%95/"/>
    <url>/2021/11/27/%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="不使用-set"><a href="#不使用-set" class="headerlink" title="不使用 set"></a>不使用 set</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">let</span> newArray = [];<br>    array.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;<br>        newArray.<span class="hljs-title function_">indexOf</span>(element) === -<span class="hljs-number">1</span> &amp;&amp; newArray.<span class="hljs-title function_">push</span>(element);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> newArray;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>forEach 和 indexof 相当于两次循环，性能低，大量数据处理速度慢</li><li>对象数组无法去重</li></ul><h3 id="使用-Set"><a href="#使用-Set" class="headerlink" title="使用 Set"></a>使用 Set</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">array</span>) &#123;<br>    <span class="hljs-keyword">let</span> newArray = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)];<br>    <span class="hljs-keyword">return</span> newArray;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：</p><ul><li>上面一样对象数组没办法去重，而且 Set 里面 NaN 认为是相同的，也可能造成问题</li></ul><h3 id="使用-Map-实现对象去重"><a href="#使用-Map-实现对象去重" class="headerlink" title="使用 Map 实现对象去重"></a>使用 Map 实现对象去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> uniq = <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">let</span> number = a[i]; <span class="hljs-comment">// 1 ~ 3 if(number === undefined)&#123;continue&#125;</span><br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(number)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        map.<span class="hljs-title function_">set</span>(number, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> [...map.<span class="hljs-title function_">keys</span>()];<br>&#125;;<br></code></pre></td></tr></table></figure><p>测试了一下可以进行对象数组去重了，缺点是兼容性比较差</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于原型链与Class的继承</title>
    <link href="/2021/11/20/%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Eclass%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/11/20/%E5%9F%BA%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8Eclass%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h2><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父级构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Shape</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 父级构造函数的原型对象</span><br><span class="hljs-title class_">Shape</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">move</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> += x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> += y;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Shape moved.&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 子级构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Rectangle</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Shape</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 继承第一步：这里用call和apply都可以，目的是使子类实例具有父类实例的属性。</span><br>&#125;<br><br><span class="hljs-title class_">Rectangle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Shape</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//继承第二步：利用create把父级构造函数的原型对象添加到子对象的原型链上</span><br><span class="hljs-title class_">Rectangle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Rectangle</span>; <span class="hljs-comment">//继承第三步：把子级构造函数的原型对象的constructor重新指回到子级构造函数上</span><br></code></pre></td></tr></table></figure><p>这里有一个疑问，第二步为什么要用 <code>create</code> 而不是直接用<code>Rectangle.prototype.__proto__=Shape.prototype</code>呢？ 因为<code>__proto__</code>并不被推荐直接使用，另外这里的 <code>create</code> 是ES6才出现的函数，如果要求必须使用ES5的话，那么第二步以及第三步可以使用以下代码代替：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Shape</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-title class_">Rectangle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>()<br></code></pre></td></tr></table></figure><h2 id="基于-class-的继承"><a href="#基于-class-的继承" class="headerlink" title="基于 class 的继承"></a>基于 class 的继承</h2><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父级class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    &#125;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子级class</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Father</span> &#123;<br>    <span class="hljs-comment">//第一步：使用extends关键词</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, z</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(x, y); <span class="hljs-comment">//第二步：使用super来表示父类构造函数，用来新建父类的this</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">z</span> = z;<br>    &#125;<br>    <span class="hljs-title function_">sonadd</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">add</span>();<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">z</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">z</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">z</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意点：</p><ul><li>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。</li><li><code>super</code>方法的调用必须在<code>constructor</code>方法的首行。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC</title>
    <link href="/2021/11/15/MVC/"/>
    <url>/2021/11/15/MVC/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-MVC"><a href="#什么是-MVC" class="headerlink" title="什么是 MVC"></a>什么是 MVC</h2><p>MVC 模式是架构模式的一种，而且是一种非常重要的且经典的构架模式。</p><p><strong>MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。</strong></p><p>这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。</p><ul><li><p>最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</p></li><li><p>最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。</p></li><li><p>中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</p></li></ul><p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。</p><p>下面对各组成部分进行简单举例说明：</p><p>操作数据相关内容都放到 m：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = &#123;<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-comment">//数据</span><br>    &#125;,<br>    <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-title function_">delete</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;&#125;,<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-comment">//操作数据相关</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>处理视图相关都放到 v:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> v = &#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">html</span>: <span class="hljs-string">``</span>, <span class="hljs-comment">//存放模版</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params">n</span>) &#123;<br>        <span class="hljs-comment">//更新视图</span><br>    &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>其他相关都放到 c:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> c = &#123;<br>  <span class="hljs-title function_">init</span>(<span class="hljs-params">container</span>) &#123;<br>    <span class="hljs-comment">//初始化工作</span><br>  &#125;,<br>  <span class="hljs-attr">events</span>: &#123;<br>    <span class="hljs-string">&#x27;click #add1&#x27;</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>    <span class="hljs-string">&#x27;click #minus1&#x27;</span>: <span class="hljs-string">&#x27;minus&#x27;</span>,<br>    <span class="hljs-string">&#x27;click #mul2&#x27;</span>: <span class="hljs-string">&#x27;mul&#x27;</span>,<br>    <span class="hljs-string">&#x27;click #divide2&#x27;</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  &#125;, <span class="hljs-comment">//绑定事件表</span><br>  <span class="hljs-title function_">autoBindEvents</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//表驱动绑定事件</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="EventBus-相关"><a href="#EventBus-相关" class="headerlink" title="EventBus 相关"></a>EventBus 相关</h2><p>Eventbus 就是事件总线，JS 实现事件总线的本质就是发布-订阅模式，达成任意组件间相互通信的作用。在一个地方触发（发布）事件，然后通过事件中心通知所有订阅者（订阅）。也就是说实现了对象间的通信</p><p>实现 Eventbus 的方法可以使用原生 API 也可以使用 jQuery，但是 eventbus 实现的功能是一样的，都需要有类似如下 API：</p><ul><li>$emit:创建触发事件，也可以用 trigger 表示</li><li>$on:订阅事件，实现事件监听</li><li>$off:解除事件绑定</li></ul><h2 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h2><p>表驱动编程其实就是将代码里重复部分的合并到一个 haspmap 里面去，再通过 forin 或者 forEach 等其他方法来实现了，目的是使代码的复杂度保持稳定，同时也更加清晰，这里直接举例进行说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">let</span> arr2 = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">switch</span> (item) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周日&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周一&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周二&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周三&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周四&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周六&#x27;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;周五&#x27;</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>这段代码是将数组中的数字替换成星期几的，用 switch 实现，看起来很冗长，如果改成使用表驱动就变成了这样，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">let</span> arr2 = arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">i</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> hash = &#123;<span class="hljs-number">0</span>:<span class="hljs-string">&#x27;周日&#x27;</span>,<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;周一&#x27;</span>,<span class="hljs-number">2</span>:<span class="hljs-string">&#x27;周二&#x27;</span>,<span class="hljs-number">3</span>:<span class="hljs-string">&#x27;周三&#x27;</span>,<span class="hljs-number">4</span>:<span class="hljs-string">&#x27;周四&#x27;</span>,<span class="hljs-number">5</span>:<span class="hljs-string">&#x27;周五&#x27;</span>,<span class="hljs-number">6</span>:<span class="hljs-string">&#x27;周六&#x27;</span>&#125;<br>  <span class="hljs-keyword">return</span> hash[i]<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2)<br></code></pre></td></tr></table></figure><p>光看起来就舒服多了，在 DOM 操作绑定事件中也可以使用这样的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-attr">events</span>: &#123;<br>  <span class="hljs-string">&#x27;click #add1&#x27;</span>: <span class="hljs-string">&#x27;add&#x27;</span>,<br>  <span class="hljs-string">&#x27;click #minus1&#x27;</span>: <span class="hljs-string">&#x27;minus&#x27;</span>,<br>  <span class="hljs-string">&#x27;click #mul2&#x27;</span>: <span class="hljs-string">&#x27;mul&#x27;</span>,<br>  <span class="hljs-string">&#x27;click #divide2&#x27;</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>&#125;,<br><span class="hljs-title function_">autoBindEvents</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> c.<span class="hljs-property">events</span>) &#123;<br>    <span class="hljs-keyword">const</span> value = c[c.<span class="hljs-property">events</span>[key]]<br>    <span class="hljs-keyword">const</span> spaceIndex = key.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">const</span> part1 = key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, spaceIndex)<br>    <span class="hljs-keyword">const</span> part2 = key.<span class="hljs-title function_">slice</span>(spaceIndex + <span class="hljs-number">1</span>)<br>    v.<span class="hljs-property">el</span>.<span class="hljs-title function_">on</span>(part1, part2, value)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码也是使用了表驱动减少了重复代码的书写。</p><h2 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h2><p>模块化的出现使用历史原因的，一开始 JS 是不支持模块化的，但是随着 JS 代码越来越臃肿和复杂，模块化的必要性就出来了，当然模块化的好处不只是单纯解决代码臃肿复杂的问题和实现团队分工，更重要的是实现了最小知识原则，也就是说引入一个模块不需要知道他做了什么，直接引入使用就可以了，非常的方便，同时使用模块也更方便我们进行解耦，因为模块与模块之前是独立的，相互之间不会影响，这也是模块化的一大好处。</p><p>关于 JS 模块化的 AMD，CMD 以及 ES6 的语法就不详细写了，资料是很多的</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2007/11/mvc.html">谈谈 MVC 模式 - 阮一峰的网络日志 (ruanyifeng.com)</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步与Promise任务</title>
    <link href="/2021/11/02/%E5%BC%82%E6%AD%A5%E4%B8%8Epromise%E4%BB%BB%E5%8A%A1/"/>
    <url>/2021/11/02/%E5%BC%82%E6%AD%A5%E4%B8%8Epromise%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><p>return new promise((resolve,reject)&#x3D;&gt;{})</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>在跨域时因为种种原因无法使用 cors，我们必须使用一个其他方式来进行跨域，于是我们请求一个 JS 文件，这个 JS 文件里面会有回调（callback），这个回调里面就有我们需要的数据，这个回调的名称不是固定的，我们通过请求 JS 的参数设置名称，引用时会把这个名称传给后台，然后后台回再次返回给我们并执行。</p><p>优点</p><ul><li>兼容 IE</li><li>跨域</li></ul><p>缺点</p><ul><li>script 标签不是 AJAX 不能读到精确的状态，比如状态码这些的都不支持，只知道成功或者失败了，onload，onerror 这种</li><li><strong>JSONP 不支持 POST</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件与事件委托</title>
    <link href="/2021/10/23/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <url>/2021/10/23/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h2 id="DOM-事件模型"><a href="#DOM-事件模型" class="headerlink" title="DOM 事件模型"></a>DOM 事件模型</h2><p>这里所说的 DOM 事件模型指的是 DOM Level 2 模式，它属于 W3C 标准模型，现代浏览器都支持该模型。在该事件模型中，一次事件共有三个过程：</p><ul><li><p><strong>事件捕获阶段（Capturing Phase）</strong>：事件从 document 一直向下传播到目标元素，依次检查经历过的节点是否绑定了事处监听函数（事件处理程序），如果有则执行，反之不执行</p></li><li><p><strong>事件处理阶段（Target Phase）</strong>：事件到达目标元素，触发目标元素的监听函数</p></li><li><p><strong>事件冒泡阶段（Bubbling Phase）</strong>：事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行，反之不执行。</p></li></ul><p>简而言之：事件一开始从文档的根节点流向目标对象（捕获阶段），然后在目标对向上被触发（目标阶段），之后再回溯到文档的根节点（冒泡阶段）。</p><p><img src="/img/pic24.png" alt="pic24"></p><ul><li>要注册事件，必须使用<code>addEventListener(&#39;click&#39;,fn,bool)</code>方法。<ul><li>如果 bool 不填或者为 falsy，则事件在冒泡阶段执行</li><li>如果 bool 为 true，则在事件在捕获阶段进行</li><li>注意，不能在什么阶段进行，捕获和冒泡这个流程都是有的</li></ul></li></ul><p>案例<a href="http://js.jirengu.com/wulagitizi/1/edit">饥人谷 JS Bin (jirengu.com)</a></p><p>注意，evt 事件在事件结束后就会被浏览器改变，如果想要再使用 evt 里的 currentTarget，可以参考上面这个案例使用变量将引用复制下来。</p><h2 id="targt-VS-currentTarget"><a href="#targt-VS-currentTarget" class="headerlink" title="targt VS currentTarget"></a>targt VS currentTarget</h2><ul><li><p>e.target 是用户操作的元素</p></li><li><p>e.currenttarget 是监听的元素</p></li><li><p>this 是 e.currentTarget</p></li><li><p>一个特例</p><ul><li>只有一个 DIV 被监听（不考虑父子同时被监听）</li><li>fn 分别在捕获阶段和冒泡阶段监听 click 事件</li><li>用户点击的元素就是开发者监听的</li><li>那么<strong>谁先监听谁先执行</strong></li></ul></li></ul><h2 id="阻止冒泡与默认行为"><a href="#阻止冒泡与默认行为" class="headerlink" title="阻止冒泡与默认行为"></a>阻止冒泡与默认行为</h2><ul><li><p>捕获不可以取消，但是冒泡可以，使用**e.stopPropagation()**可以阻止冒泡</p></li><li><p>阻止默认行为使用**e.preventDefault()**，可以使用 MDN 查阅事件是否冒泡（Bubbles）以及是否能取消默认行为（Cancelable），是否能取消默认行为与冒泡无关</p></li></ul><p>这里就有一个问题，查阅 scroll 的 MDN 页面我们可以知道，scroll 是不能取消默认行为的，因为是先滚动后触发的，那我们如何阻止滚动呢？</p><ul><li>首先我们可以阻止鼠标滚轮（wheel）和触摸（touchstart）的默认行为来实现，但是直接拖动滚动条还是可以滚动</li><li>那我们可以使用 CSS 直接使滚动条 width 为 0(代码为<code>::webkit-scrollbar&#123;width:0!important&#125;</code>）就可以了</li></ul><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>浏览器事件是很多的，共有 100 多种，可以参考 MDN 进行查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">事件参考 | MDN (mozilla.org)</a></p><ul><li>鼠标经过的四个事件特征需要记一下：<a href="https://www.cnblogs.com/xpl-blogs/p/6528012.html">JavaScript 里 mouseenter 和 mouseleave 与 mouseover 和 mouseout 的区别 - xplblog - 博客园 (cnblogs.com)</a></li></ul><p>当然我们也可以自定义一个事件，示例如下：</p><p><img src="/img/pic25%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%89.png" alt="pic25（自定义事件）"></p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul><li>定义：<ul><li>利用事件冒泡的特性，将本应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现其本身没有相应事件就到父元素上寻找作出响应。</li></ul></li><li>优点：<ul><li>节省监听数，减少内存消耗，提高性能</li><li>随时可以添加子元素，添加的子元素会自动有相应的处理事件，也就是可以监听动态元素</li></ul></li></ul><p>封装一个事件委托函数</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">on</span>(<span class="hljs-params">eventType, element, selecton, fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (element <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Element</span>) &#123;<br>        element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(element);<br>    &#125;<br>    element.<span class="hljs-title function_">addEventListener</span>(eventType, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> t = e.<span class="hljs-property">target</span>;<br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-title function_">matches</span>(selector)) &#123;<br>            <span class="hljs-title function_">fn</span>(e);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数在 matchers 这段是存在问题的，因为用户点击的元素可能与 selector 不一致，这时我们需要使用递归判断一下 target 的父级元素，可以参考这里进行修改<a href="https://github.com/FrankFang/wheels/blob/master/lib/dom/index.js#L2">wheels&#x2F;index.js at master · FrankFang&#x2F;wheels (github.com)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">on</span>(<span class="hljs-params">element, eventType, selector, fn</span>) &#123;<br>    element.<span class="hljs-title function_">addEventListener</span>(eventType, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> el = e.<span class="hljs-property">target</span>;<br>        <span class="hljs-keyword">while</span> (!el.<span class="hljs-title function_">matches</span>(selector)) &#123;<br>            <span class="hljs-keyword">if</span> (element === el) &#123;<br>                el = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            el = el.<span class="hljs-property">parentNode</span>;<br>        &#125;<br>        el &amp;&amp; fn.<span class="hljs-title function_">call</span>(el, e, el);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后一个问题，JS 支持事件吗？</p><p>实际上以上所说的 DOM 事件并非 JS 的功能，而是属于浏览器提供的 DOM 的功能，浏览器只是调用 DOM 提供的 addEventListener 而已。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery中的设计模式</title>
    <link href="/2021/10/18/JQuery%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/18/JQuery%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="jQuery-获取网页元素"><a href="#jQuery-获取网页元素" class="headerlink" title="jQuery 获取网页元素"></a>jQuery 获取网页元素</h2><p>jQuery 的基本设计思想和主要用法，就是**”选择某个网页元素，然后对其进行某种操作”**。这是它区别于其他 Javascript 库的根本特点。</p><p>使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery()（简写为$），然后得到被选中的元素。</p><p>选择表达式可以是 CSS 选择器：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-variable language_">document</span>); <span class="hljs-comment">//选择整个文档对象</span><br><br>$(<span class="hljs-string">&#x27;#myId&#x27;</span>); <span class="hljs-comment">//选择ID为myId的网页元素</span><br><br>$(<span class="hljs-string">&#x27;div.myClass&#x27;</span>); <span class="hljs-comment">// 选择class为myClass的div元素</span><br><br>$(<span class="hljs-string">&#x27;input[name=first]&#x27;</span>); <span class="hljs-comment">// 选择name属性等于first的input元素</span><br></code></pre></td></tr></table></figure><p>也可以是 jQuery<a href="https://www.jquery123.com/category/selectors/">特有的表达式</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;a:first&#x27;</span>); <span class="hljs-comment">//选择网页中第一个a元素</span><br><br>$(<span class="hljs-string">&#x27;tr:odd&#x27;</span>); <span class="hljs-comment">//选择表格的奇数行</span><br><br>$(<span class="hljs-string">&#x27;#myForm :input&#x27;</span>); <span class="hljs-comment">// 选择表单中的input元素</span><br><br>$(<span class="hljs-string">&#x27;div:visible&#x27;</span>); <span class="hljs-comment">//选择可见的div元素</span><br><br>$(<span class="hljs-string">&#x27;div:gt(2)&#x27;</span>); <span class="hljs-comment">// 选择所有的div元素，除了前三个</span><br><br>$(<span class="hljs-string">&#x27;div:animated&#x27;</span>); <span class="hljs-comment">// 选择当前处于动画状态的div元素</span><br></code></pre></td></tr></table></figure><p>我们也可以使用各种<a href="https://www.jquery123.com/category/traversing/filtering/">过滤器</a>对结果集进行进一步的筛选，缩小选择结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;p&#x27;</span>); <span class="hljs-comment">// 选择包含p元素的div元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">not</span>(<span class="hljs-string">&#x27;.myClass&#x27;</span>); <span class="hljs-comment">//选择class不等于myClass的div元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;.myClass&#x27;</span>); <span class="hljs-comment">//选择class等于myClass的div元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">first</span>(); <span class="hljs-comment">//选择第1个div元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">//选择第6个div元素</span><br></code></pre></td></tr></table></figure><p>有时候，我们需要从结果集出发，移动到附近的相关元素，jQuery 也提供了在 DOM 树上的<a href="https://www.jquery123.com/category/traversing/tree-traversal/">移动方法</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;p&#x27;</span>); <span class="hljs-comment">//选择div元素后面的第一个p元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">parent</span>(); <span class="hljs-comment">//选择div元素的父元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">closest</span>(<span class="hljs-string">&#x27;form&#x27;</span>); <span class="hljs-comment">//选择离div最近的那个form父元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">children</span>(); <span class="hljs-comment">//选择div的所有子元素</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">siblings</span>(); <span class="hljs-comment">//选择div的同级元素</span><br></code></pre></td></tr></table></figure><h2 id="jQuery-链式操作"><a href="#jQuery-链式操作" class="headerlink" title="jQuery 链式操作"></a>jQuery 链式操作</h2><p>jQuery 的链式操作，就是指最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;h3&#x27;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br></code></pre></td></tr></table></figure><p>分解开来，就是下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>) <span class="hljs-comment">//找到div元素</span><br>    .<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;h3&#x27;</span>) <span class="hljs-comment">//选择其中的h3元素</span><br><br>    .<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//选择第3个h3元素</span><br><br>    .<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>); <span class="hljs-comment">//将它的内容改为Hello</span><br></code></pre></td></tr></table></figure><p>这是 jQuery 最令人称道、最方便的特点。它的原理在于每一步的 jQuery 操作，返回的都是一个 jQuery 对象，所以不同操作可以连在一起。</p><p>jQuery 还提供了<a href="https://www.jquery123.com/end/">.end()</a> 方法，使得结果集可以后退一步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>)<br>    .<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;h3&#x27;</span>)<br><br>    .<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>)<br><br>    .<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br><br>    .<span class="hljs-title function_">end</span>() <span class="hljs-comment">//退回到选中所有的h3元素的那一步</span><br><br>    .<span class="hljs-title function_">eq</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">//选中第一个h3元素</span><br><br>    .<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;World&#x27;</span>); <span class="hljs-comment">//将它的内容改为World</span><br></code></pre></td></tr></table></figure><h2 id="元素的操作：创建、复制和删除"><a href="#元素的操作：创建、复制和删除" class="headerlink" title="元素的操作：创建、复制和删除"></a>元素的操作：创建、复制和删除</h2><p>jQuery 创建新元素的方法非常简单，只要把新元素直接传入 jQuery 的构造函数就行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>);<br><br>$(<span class="hljs-string">&#x27;&lt;li class=&quot;new&quot;&gt;new list item&lt;/li&gt;&#x27;</span>);<br><br>$(<span class="hljs-string">&#x27;ul&#x27;</span>).<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;&lt;li&gt;list item&lt;/li&gt;&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li><p>复制元素使用<a href="https://www.jquery123.com/clone/">.clone()</a>。</p></li><li><p>删除元素使用<a href="https://www.jquery123.com/remove/">.remove()</a>和<a href="https://www.jquery123.com/detach/">.detach()</a>。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。</p></li><li><p>清空元素内容（但是不删除该元素）使用<a href="https://www.jquery123.com/empty/">.empty()</a>。</p></li></ul><h2 id="元素的操作：移动"><a href="#元素的操作：移动" class="headerlink" title="元素的操作：移动"></a>元素的操作：移动</h2><p>jQuery 提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。</p><p>假定我们选中了一个 div 元素，需要把它移动到 p 元素后面。</p><p>第一种方法是使用<a href="https://www.jquery123.com/insertAfter/">.insertAfter()</a>，把 div 元素移动 p 元素后面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">insertAfter</span>($(<span class="hljs-string">&#x27;p&#x27;</span>));<br></code></pre></td></tr></table></figure><p>第二种方法是使用<a href="https://www.jquery123.com/after/">.after()</a>，把 p 元素加到 div 元素前面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;p&#x27;</span>).<span class="hljs-title function_">after</span>($(<span class="hljs-string">&#x27;div&#x27;</span>));<br></code></pre></td></tr></table></figure><p>表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回 div 元素，第二种方法返回 p 元素。你可以根据需要，选择到底使用哪一种方法。</p><p>使用这种模式的操作方法，一共有四对：</p><ul><li><p><a href="https://www.jquery123.com/insertAfter/">.insertAfter()</a>和<a href="https://www.jquery123.com/after/">.after()</a>：在现存元素的外部，从后面插入元素</p></li><li><p><a href="https://www.jquery123.com/insertBefore/">.insertBefore()</a>和<a href="https://www.jquery123.com/before">.before()</a>：在现存元素的外部，从前面插入元素</p></li><li><p><a href="https://www.jquery123.com/appendTo/">.appendTo()</a>和<a href="https://www.jquery123.com/append">.append()</a>：在现存元素的内部，从后面插入元素</p></li><li><p><a href="https://www.jquery123.com/prependTo/">.prependTo()</a>和<a href="https://www.jquery123.com/prepend">.prepend()</a>：在现存元素的内部，从前面插入元素</p></li></ul><h2 id="元素的操作：取值和赋值-包括对属性进行修改"><a href="#元素的操作：取值和赋值-包括对属性进行修改" class="headerlink" title="元素的操作：取值和赋值(包括对属性进行修改)"></a>元素的操作：取值和赋值(包括对属性进行修改)</h2><p>操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。</p><p>jQuery 会使用同一个函数，来完成取值（getter）和赋值（setter），即”取值器”与”赋值器”合一。到底是取值还是赋值，由函数的参数决定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;h1&#x27;</span>).<span class="hljs-title function_">html</span>(); <span class="hljs-comment">//html()没有参数，表示取出h1的值</span><br><br>$(<span class="hljs-string">&#x27;h1&#x27;</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>); <span class="hljs-comment">//html()有参数Hello，表示对h1进行赋值</span><br></code></pre></td></tr></table></figure><p>常见的取值和赋值函数如下：</p><ul><li><p><a href="https://www.jquery123.com/html/">.html()</a> 取出或设置 html 内容</p></li><li><p><a href="https://www.jquery123.com/text/">.text()</a> 取出或设置 text 内容</p></li><li><p><a href="https://www.jquery123.com/attr/">.attr()</a> 取出或设置某个属性的值</p></li><li><p><a href="https://www.jquery123.com/width/">.width()</a> 取出或设置某个元素的宽度</p></li><li><p><a href="https://www.jquery123.com/height/">.height()</a> 取出或设置某个元素的高度</p></li><li><p><a href="https://www.jquery123.com/val/">.val()</a> 取出某个表单元素的值</p></li></ul><p>我们使用<a href="https://www.jquery123.com/attr/">.attr()</a> 来实现对元素属性的修改，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#mylink&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>); <span class="hljs-comment">//修改a标签的herf属性</span><br></code></pre></td></tr></table></figure><p>另外需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（<a href="https://www.jquery123.com/text/">.text()</a>例外，它取出所有元素的 text 内容）。</p><h2 id="元素的操作：CSS-属性操作"><a href="#元素的操作：CSS-属性操作" class="headerlink" title="元素的操作：CSS 属性操作"></a>元素的操作：CSS 属性操作</h2><p>jQuery 进行 CSS 操作的方法有如下几个：</p><ul><li><a href="https://www.jquery123.com/addClass/#addClass-className">.addClass()</a> - 向被选元素添加一个或多个类</li><li><a href="https://www.jquery123.com/removeClass/#removeClass-className">.removeClass()</a> - 从被选元素删除一个或多个类</li><li><a href="https://www.jquery123.com/toggleClass/#toggleClass-className">.toggleClass()</a> - 对被选元素进行添加&#x2F;删除类的切换操作</li><li><a href="https://www.jquery123.com/css/#css-propertyName">.css()</a>设置或返回样式属性</li></ul><p>这里的<a href="https://www.jquery123.com/css/#css-propertyName">.css()</a>需要单独记忆一下，它也是一个”取值器”与”赋值器”合一的函数，使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">$(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>); <span class="hljs-comment">//获取CSS属性</span><br>$(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&quot;background-color&quot;</span>,<span class="hljs-string">&quot;yellow&quot;</span>); <span class="hljs-comment">//设置CSS属性</span><br>$(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">css</span>(&#123;<span class="hljs-string">&quot;background-color&quot;</span>:<span class="hljs-string">&quot;yellow&quot;</span>,<span class="hljs-string">&quot;font-size&quot;</span>:<span class="hljs-string">&quot;200%&quot;</span>&#125;); <span class="hljs-comment">//设置多个CSS属性，每个属性采用键值对形式，用逗号隔开</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html">jQuery 设计思想 - 阮一峰的网络日志 (ruanyifeng.com)</a></p></li><li><p><a href="https://www.jquery123.com/">jQuery API 中文文档 | jQuery 中文网 (jquery123.com)</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>JQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dom编程</title>
    <link href="/2021/10/15/DOM%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/15/DOM%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ul><li><p>获取元素</p><ul><li>window.id 或者直接用 id 就可以（前提为 id 未被使用）</li><li>document.getElementByid(‘id’)</li><li>document.getElementsbyTagname(‘div’)[0]</li><li>document.getElemenstbyClassName(‘red’)[0]</li><li>document.querySelector(‘#id’)</li><li>Document.querySelectorAll(‘.red’)[0]</li><li>几个特殊情况<ul><li>获取 html 元素<ul><li>document.documentElement</li></ul></li><li>获取 head 元素<ul><li>document.head</li></ul></li><li>获取 body 元素<ul><li>document.body</li></ul></li><li>获取窗口（窗口不是元素）<ul><li>window</li></ul></li><li>获取所有元素<ul><li>document.all(<strong>document.all 是第六个 falsy 值</strong>)</li></ul></li></ul></li></ul></li><li><p>元素的 6 层原型链</p><p><img src="/images/pic20(DOM%E5%85%83%E7%B4%A06%E5%B1%82%E5%8E%9F%E5%9E%8B%E9%93%BE).png" alt="pic20(DOM元素6层原型链)"></p></li></ul><h2 id="元素的增删改查"><a href="#元素的增删改查" class="headerlink" title="元素的增删改查"></a>元素的增删改查</h2><ul><li>增<ul><li>创建一个标签节点<ul><li>let div1 &#x3D; document.createElement(‘div’)</li></ul></li><li>创建一个文本节点<ul><li>text1 &#x3D; document.createTextNode(‘你好’)</li></ul></li><li>标签里面插入文本<ul><li>div.appendchild(text1)</li><li>Div.innerText &#x3D; ‘hello’或 div1.textContent&#x3D; ‘hello’</li><li><strong>但是不能用 div.appendchild(‘你好’)</strong></li></ul></li><li>插入页面之中<ul><li>Document.body.appendchild(div)</li><li>已在页面中的元素.append(div)</li><li><strong>一个元素不能放在两个地方，除非复制（cloneNode）一份</strong></li></ul></li></ul></li><li>删<ul><li>childNode.remove()</li></ul></li><li>改<ul><li>改 class：div.className &#x3D; ‘red’ &#x2F;&#x2F;会覆盖</li><li>改 class：div.classList.add(‘red’)</li><li>改 style：div.style &#x3D; “width:100px;color:red;”</li><li>改 style 的一部分：div.style.width &#x3D; ‘200px’</li><li>注意大小写：div.style.backgroundColor&#x3D;’red’</li><li><strong>改 data-*属性：div.dataset.x&#x3D;’frank’</strong></li><li>读属性<ul><li>div.classList&#x2F;a.herf(<strong>直接使用可能会获取到被浏览器加工的值，</strong>)</li><li>div.getAttribute(‘class’)&#x2F;a.getAttribute(‘herf’)</li></ul></li><li>改事件处理函数<ul><li>div.onclick 默认为 null</li><li>设置 div.onclick&#x3D;fn()是这样调用的 fn.call(div,evt)，也就是<strong>说 this 是被设置为 div</strong>，evt 是事件函数</li><li>div.addEventListener</li></ul></li><li>改内容<ul><li>div.innerText &#x3D; ‘xxx’</li><li>Div.textContent&#x3D;’xxx’</li><li>都是一样的，我一般用 innerText</li></ul></li><li>改 html 内容<ul><li>div.innerHTML&#x3D;’’</li></ul></li><li>改标签<ul><li>div.innerHTML&#x3D;’’&#x2F;&#x2F;先清空</li><li>div.appendChild(div2)&#x2F;&#x2F;再加内容</li></ul></li></ul></li><li>查<ul><li>父级元素<ul><li>node.parentNode 或者 node.parentElement</li><li>Node.parentNode.parentNode</li></ul></li><li>子级元素<ul><li>node.childNodes 或者 node.children</li></ul></li><li>查同级元素<ul><li>node.parentNode.childNodes(需要另外排除自己)</li><li>node.parentNode.children(需要另外排除自己)</li></ul></li><li>查第一个元素<ul><li>node.firstchild</li></ul></li><li>查看最后一个元素<ul><li>node.lastchild</li></ul></li><li>查看上一个节点&#x2F;元素<ul><li>node.previousSibing&#x2F;node.previousElementsibing</li></ul></li><li>查看下一个节点&#x2F;元素<ul><li>node.nextSibing&#x2F;node.nextElementsibing</li></ul></li></ul></li></ul><h2 id="DOM-操作是跨线程的"><a href="#DOM-操作是跨线程的" class="headerlink" title="DOM 操作是跨线程的"></a>DOM 操作是跨线程的</h2><p>浏览器有 JS 引擎和渲染引擎，JS 不能操作页面，只能操作 JS，反之渲染引擎也只能操作页面，不能操作页面</p><p><img src="/images/pic21.png" alt="pic21"></p><p><img src="/images/pic22.png" alt="pic22"></p><p><img src="/images/pic23.png" alt="pic23"></p><p>关于为什么操作 DOM 慢可以再看一下下面的文章：</p><p><a href="https://segmentfault.com/a/1190000004114594">为什么说 DOM 操作很慢 - SegmentFault 思否</a></p><p><a href="https://stackoverflow.com/questions/6817093/but-whys-the-browser-dom-still-so-slow-after-10-years-of-effort">javascript - But why’s the browser DOM still so slow after 10 years of effort? - Stack Overflow</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 小结</title>
    <link href="/2021/10/07/Js%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/10/07/Js%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/pic16.png" alt="pic16"></p><p><img src="/img/pic17.png" alt="pic17"></p><p><img src="/img/pic18.png" alt="pic18"></p><p><img src="/img/pic19.png" alt="pic19"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 运算符</title>
    <link href="/2021/10/05/JS%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/10/05/JS%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ul><li>number 运算<ul><li>加减乘除</li><li>余数 x % 7</li><li>指数 x ** 3</li><li>自增自减 x++ &#x2F; ++x &#x2F; x– &#x2F; –x</li><li>求值运算符 +x</li><li>负数运算符 -x</li></ul></li><li>string 运算<ul><li>连接运算 ‘123’ + ‘456’</li></ul></li></ul><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul><li>\</li><li>&lt;</li><li>&#x3D;</li><li>&lt;&#x3D;</li><li>&#x3D;&#x3D;</li><li>!&#x3D;</li><li>&#x3D;&#x3D;&#x3D;</li><li>!&#x3D;&#x3D;</li></ul><p><img src="/images/pic15.png" alt="pic15"></p><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><ul><li>或且非<ul><li>||</li><li>&amp;&amp;</li><li>!</li></ul></li><li>短路逻辑<ul><li>console &amp;&amp; console.log &amp;&amp; console.log(‘hi’)</li><li>以防 console 不存在报错</li><li>a &#x3D; a || 100</li><li>a 的保底值</li></ul></li></ul><h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><ul><li><p>或、与、否</p><ul><li>两个位都为 0，则结果为 0，否则为 1</li><li>&amp;</li><li>~<ul><li><strong>一个数与自身的取反值相加等于-1</strong></li></ul></li></ul></li><li><p>异或</p><ul><li>^</li><li>两个位相同，则结果为 0，否则为 1</li></ul></li><li><p>左移右移</p><ul><li>&lt;&lt; 和 &gt;&gt;</li></ul></li><li><p>头部补零的右移运算符</p><ul><li>&gt;&gt;&gt;</li></ul></li><li><p>详情参考<a href="https://juejin.cn/post/6844903568906911752">位运算符在 JS 中的妙用 - 掘金 (juejin.cn)</a></p></li><li><p>面试问题</p><ul><li><p>使用与运算符判断奇偶</p><ul><li>偶数 &amp; 1 &#x3D;&#x3D; 0</li><li>奇数 &amp; 1 &#x3D;&#x3D; 1</li></ul></li><li><p>使用~, &gt;&gt;, &lt;&lt;, &gt;&gt;&gt;, |来取整</p><ul><li>console.log(~~ 6.83) &#x2F;&#x2F; 6</li><li>console.log(6.83 &gt;&gt; 0) &#x2F;&#x2F; 6</li><li>console.log(6.83 &lt;&lt; 0) &#x2F;&#x2F; 6</li><li>console.log(6.83 | 0) &#x2F;&#x2F; 6</li><li>console.log(6.83 &gt;&gt;&gt; 0) &#x2F;&#x2F; 6</li></ul></li><li><p>使用^来交换 a b 的值</p><ul><li><p>var a &#x3D; 5</p><p>var b &#x3D; 8</p><p>a ^&#x3D; b</p><p>b ^&#x3D; a</p><p>a ^&#x3D; b</p><p>console.log(a) &#x2F;&#x2F; 8</p><p>console.log(b) &#x2F;&#x2F; 5</p></li><li><p>其实使用结构赋值更好，[a,b]&#x3D;[b,a]</p></li></ul></li></ul><h2 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符"></a>点运算符</h2><ul><li>语法<ul><li>对象.属性名 &#x3D; 属性值</li></ul></li><li>作用<ul><li>读取对象的属性值</li></ul></li><li>有个疑问</li><li>不是对象，为什么也可以有属性？’a-b-c’.split(‘-‘)</li><li>JS 有特殊逻辑，点前面不是对象，就把它封装成对象</li><li>number 会变成 Number 对象</li><li>string 会变成 String 对象</li><li>bool 会变成 Boolean 对象</li><li>程序员从来不用这三种对象，只用简单类型</li></ul><h2 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h2><ul><li>语法<ul><li>void 表达式或语句</li></ul></li><li>作用<ul><li>求表达式的值，或执行语句</li><li>然后 void 的值总是为 undefined</li></ul></li><li>需求<ul><li>&lt;a href&#x3D;”<a href="http://example.com&quot;/">http://example.com&quot;</a> onclick&#x3D;”f(); return false;”&gt;点击&lt;&#x2F;a&gt;</li><li>return 假值可以阻止默认动作</li><li>&lt;a href&#x3D;”javascript: void(f())”&gt;文字&lt;&#x2F;a&gt;</li><li>改用 void 可以炫技</li></ul></li></ul></li></ul><h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><ul><li>语法<ul><li>表达式 1, 表达式 2, …, 表达式 n</li></ul></li><li>作用<ul><li>将表达式 n 的值作为整体的值</li></ul></li><li>使用<ul><li>let a &#x3D; (1,2,3,4,5)</li><li>那么 a 的值就是 5，奇葩吧？</li><li>let f &#x3D; (x) &#x3D;&gt; (console.log(‘平方值为’), x*x)</li><li>注意上面的括号不能省</li></ul></li></ul><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>见此篇 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table">运算符优先级 - JavaScript | MDN (mozilla.org)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 函数</title>
    <link href="/2021/10/04/JS%E5%87%BD%E6%95%B0/"/>
    <url>/2021/10/04/JS%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数的四种定义方法及组成"><a href="#函数的四种定义方法及组成" class="headerlink" title="函数的四种定义方法及组成"></a>函数的四种定义方法及组成</h2><p>首先，要明确一点就是函数本身也是一个对象。</p><ol><li><p>具名函数</p><p> <code>function 函数名 (形式参数1，形式参数2)&#123;语句 return 返回值&#125;</code></p></li><li><p>匿名函数</p><ul><li><p>上面的具名函数去掉函数名就是匿名函数</p></li><li><p>例如 <code>let a = function(x,y)&#123;return x+y&#125;</code></p></li><li><p>也叫函数表达体</p></li></ul></li></ol><p>我们可以把匿名函数和具名函数结合起来使用，如 <code>let a =function fn(x,y)&#123;return x+y&#125;</code> ，那么需要注意的是这时只能通过 a(x,y) 来调用函数，fn(x,y)不能调用函数，因为 fn 的作用域只在等号之后存在，在外部无法访问到 fn。</p><ol start="3"><li><p>箭头函数</p><ul><li><p><code>let f1 = x =&gt; x*x</code></p></li><li><p><code>let f2 = (x,y) =&gt; x+y // 包含两个及以上形参时圆括号不能省</code></p></li><li><p><code>f3 = (x,y) =&gt; &#123;console.log(&#39;hi&#39;);return x+y&#125; // 函数体包含两句以上语句时花括号不能省</code></p></li><li><p><code>let f4 = (x,y) =&gt; (&#123;name:x, age: y&#125;)</code> &#x2F;&#x2F;当箭头函数返回一个对象时，为了避免对象被识别为块从而出现报错的情况，这里的解决办法是<strong>使用一个圆括号将返回对象包起来</strong></p></li></ul></li><li><p>用构造函数</p><ul><li><p><code>let f = new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x+y&#39;)</code></p></li><li><p>很少使用，但是能让你知道函数是谁构造的</p></li><li><p>所有函数都是 Function 构造出来的</p></li><li><p>包括 Object、Array、Function 也是</p></li></ul></li></ol><p>每个函数都包含以下内容</p><ul><li>调用时机</li><li>作用域</li><li>闭包</li><li>形式参数</li><li>返回值</li><li>调用栈</li><li>函数提升</li><li>arguments（除了箭头函数）</li><li>this（除了箭头函数）</li></ul><h2 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h2><p>结合例子单独开一篇来讲</p><h2 id="作用域-amp-闭包"><a href="#作用域-amp-闭包" class="headerlink" title="作用域&amp;闭包"></a>作用域&amp;闭包</h2><ul><li><p>全局变量 VS 局部变量</p><ul><li>在顶级作用域下声明的变量就是全局变量</li><li><strong>window 的属性是全局变量</strong></li><li>除此之外的全部是局部变量</li></ul></li><li><p>作用域的嵌套</p><ul><li><p>如果多个作用域有同名变量 a</p><ul><li><p>那么查找 a 的声明时，就向上取最近的作用域</p></li><li><p>简称「就近原则」</p></li><li><p>查找 a 的过程与函数执行无关</p></li><li><p>但 a 的值与函数执行有关</p></li></ul></li><li><p>以上其实说的就是作用域链，只要记住<strong>就近原则</strong>这一点就能弄明白了</p></li></ul></li><li><p>闭包</p><ul><li><strong>如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包</strong>详情以后再补充</li></ul></li></ul><h2 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h2><ul><li>形式参数<ul><li>形参的就是非实际参数</li><li>形参可以认为就是变量声明</li></ul></li><li>返回值<ul><li>每一个函数都有返回值</li><li>函数执行完了才有返回值</li><li>只有函数才有返回值<ul><li><del>1+2 的返回值是 3</del></li><li>1+2 的值是 3</li></ul></li></ul></li></ul><h2 id="递归、调用栈、爆栈与函数提升"><a href="#递归、调用栈、爆栈与函数提升" class="headerlink" title="递归、调用栈、爆栈与函数提升"></a>递归、调用栈、爆栈与函数提升</h2><p>什么是调用栈</p><ul><li><p>JS 引擎在调用一个函数前</p></li><li><p>需要把函数所在的环境 push 到一个数组里（压栈）</p></li><li><p>这个数组叫做<strong>调用栈</strong></p></li><li><p>等函数执行完了，就会把环境弹(pop)出来（弹栈）</p></li><li><p>然后 return 到之前的环境，继续执行后续代码</p></li><li><p>调用栈最长有多少？，使用如下函数可以测试调用栈有多长</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">computeMaxCallStackSize</span>(<span class="hljs-params"></span>) &#123;<br><br> <span class="hljs-keyword">try</span> &#123;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-title function_">computeMaxCallStackSize</span>();<br><br> &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br><br>  <span class="hljs-comment">// 报错说明 stack overflow 了</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br> &#125;<br></code></pre></td></tr></table></figure><ul><li><p>Chrome 12578</p></li><li><p>Firefox 26773</p></li><li><p>Node 12536</p></li></ul></li><li><p>爆栈：如果调用栈中压入的帧过多，程序就会崩溃</p></li></ul><p>变量提升</p><ul><li><p>什么是变量提升</p><ul><li>function fn(){}</li><li>不管你把具名函数声明在哪里，它都会跑到第一行</li></ul></li><li><p>什么不是函数提升</p><ul><li><p>let fn &#x3D; function(){}</p></li><li><p>这是赋值，右边的匿名函数声明不会提升（let 没有变量提升）</p></li></ul></li></ul><h2 id="arguments-与-this"><a href="#arguments-与-this" class="headerlink" title="arguments 与 this"></a>arguments 与 this</h2><ul><li><p>arguments</p><p>是一个伪数组，使用 Array.from 转化为数组</p></li><li><p>this</p><ul><li><p>如果没有任何指示，那么 this 就指向 window</p></li><li><p>目前可以用 fn.call(xxx, 1,2,3) 传 this 和 arguments</p><p>如果没有使用严格模式那么 xxx 会被自动转化成对象（JS 的糟粕），如果使用严格模式那么就是原本的 xxx</p></li><li><p>绑定 this</p><ul><li><p>使用 bind() 可以让 this 不再改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">p1, p2</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>, p1, p2);<br>&#125;<br><span class="hljs-keyword">let</span> f2 = f1.<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;frank&#x27;</span> &#125;);<br><span class="hljs-comment">// 那么 f2 就是 f1 绑定了 this 之后的新函数</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 等价于 f1.call(&#123;name:&#x27;frank&#x27;&#125;)</span><br></code></pre></td></tr></table></figure></li><li><p>.bind 还可以绑定其他参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> f3 = f1.<span class="hljs-title function_">bind</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;frank&#x27;</span> &#125;, <span class="hljs-string">&#x27;hi&#x27;</span>);<br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 等价于 f1.call(&#123;name:&#x27;frank&#x27;&#125;, hi)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>没有 arguments 和自己的 this</strong></p><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>原理</p><ul><li><p>ES 5 时代，为了得到局部变量，必须引入一个函数</p></li><li><p>但是这个函数如果有名字，就得不偿失</p></li><li><p>于是这个函数必须是匿名函数</p></li><li><p>声明匿名函数，然后立即加个 () 执行它</p></li><li><p>但是 JS 标准认为这种语法不合法</p></li><li><p>所以 JS 程序员寻求各种办法</p></li><li><p>最终发现，只要在匿名函数前面加个运算符即可</p></li><li><p>!、~、()、+、- 都可以</p></li><li><p>但是这里面有些运算符会往上走</p></li><li><p><strong>所以推荐永远用 ! 来解决</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 函数的执行时机</title>
    <link href="/2021/10/01/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%88%E7%BB%93%E5%90%88%E4%BE%8B%E5%AD%90%EF%BC%89/"/>
    <url>/2021/10/01/JS%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%EF%BC%88%E7%BB%93%E5%90%88%E4%BE%8B%E5%AD%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>现有代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125; <span class="hljs-comment">//输出6个6</span><br></code></pre></td></tr></table></figure><p>为什么会输出 6 个 6 而不是 0、1、2、3、4、5 呢？这里只要明确一点：<strong>JS 语言的一大特征是单线程，而 setTimeout 是异步执行的</strong>；再结合阮一峰老师的这篇博客 <a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈 Event Loop - 阮一峰的网络日志 (ruanyifeng.com)</a> ，就能大致明白是怎么回事了，简单来说因为 setTimeout 是异步执行的，这个和设置的延迟时间没有关系，设置成 0 还是 10000 都是一样在执行过程中被认为是异步任务，而异步任务必须等待主线程上排队执行的同步任务执行完成，系统开始读取任务队列之后开始执行，而此时 i 在主线程上经历了 for 循环之后，里面的值已经累加到了 6，所以此时异步任务再执行输出自然就是 6 个 6 了。</p><p>如果再执行如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//输出 0 1 2 3 4 5</span><br></code></pre></td></tr></table></figure><p>为什么这里输出又变成了 0，1，2，3，4，5 呢？这里是因为<strong>let 的块级作用域</strong>造成的，和第一段代码不同，这里的 i 被定义在循环体内部，因为 for 循环了 6 次，相当于产生了 6 个块级作用域，而在每个块级作用域里面，i 的值分别是 0，1，2，3，4，5，当系统开始执行任务队列里的异步任务时，就会将 i 的这 6 个值输出，就是 0，1，2，3，4，5 了。</p><p>那么还有其他方法可以做到输出 0，1，2，3，4，5 吗？在网上找到了如下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//第一种</span><br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<br>        <span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>        &#125;,<br>        <span class="hljs-number">0</span>,<br>        i<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法利用了给 setTimeout 传参来实现，详情参考此博客<a href="http://caibaojian.com/about-settimeout.html">关于 setTimeout()你所不知道的地方,详解 setTimeout()-前端开发博客 (caibaojian.com)</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//第二种</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>    !(<span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);<br>        &#125;, <span class="hljs-number">0</span>);<br>    &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建立即执行函数，将 i 传到立即执行函数中产生独立的作用域，也可以实现输出 0，1，2，3，4，5。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 对象基本用法</title>
    <link href="/2021/09/25/JS%E6%95%B0%E7%BB%84/"/>
    <url>/2021/09/25/JS%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数组究竟是什么"><a href="#数组究竟是什么" class="headerlink" title="数组究竟是什么"></a>数组究竟是什么</h2><ul><li>js 其实没有真正的数组，而使用对象模拟的数组</li><li>典型的数组<ul><li>元素的类型相同</li><li>使用连续的内存存储</li><li>通过数字下标获取元素</li></ul></li><li>JS 的数组<ul><li>元素的类型可以不同</li><li>内存不一定是连续的（对象是随机存储的）</li><li>不能通过数字下标获取，而是通过字符串获取<ul><li>这意味着数组可以有任意 KEY，比如 <code>let a = [1,2,3] a[&#39;xxx&#39;]=xxx</code>在 JS 中是完全合法的</li></ul></li></ul></li><li>如何创建一个数组<ul><li>新建<ul><li><code>let a = [1,2,3]</code></li><li><code>let a = new Array(1,2,3)</code></li><li><code>let a = new Array(3)</code></li></ul></li><li>转化<ul><li><code>let a = &#39;1,2,3&#39;.spite(&#39;,&#39;)</code></li><li><code>let a = &#39;123&#39;.spite()</code></li><li><code>Array.from(&#39;123&#39;)</code></li></ul></li><li>伪数组<ul><li><code>let divlist =document.queryselctorAll(&#39;div&#39;)</code></li><li>伪数组的原型链中并没有数组的原型，需要进行转化（使用 Array.from()）才能使用数组的方法</li></ul></li><li>合并两个数组得到一个新数组<ul><li>arr1.concat(arr4)</li></ul></li><li>截取数组的一部分成为新数组<ul><li>Arr.slice(1)&#x2F;&#x2F;从第二个元素开始</li><li>arr.slice(0)&#x2F;&#x2F;全部截取，是拷贝的方法</li><li><strong>注意，JS 只提供浅拷贝</strong></li></ul></li></ul></li></ul><h2 id="数组元素的删除"><a href="#数组元素的删除" class="headerlink" title="数组元素的删除"></a>数组元素的删除</h2><ul><li>可以使用对象一样的方法 <code>delete arr[0]</code> ,但是<strong>数组的长度不会改变</strong>，会产生一个稀疏数组，但是不推荐这样做</li><li>修改 length 可以直接删除长度后面的元素，也不推荐这样做</li><li>推荐的做法<ul><li>删除第一个元素：<code>arr.shift() //arr被修改，返回第一个元素</code></li><li>删除最后一个元素： <code>arr.pop()//arr被修改，返回最后一个元素</code></li><li>删除中间的元素：<ul><li><code>arr.splice(index,1)//删除index的第一个元素</code></li><li><code>arr.splice(index,1,&#39;x&#39;)//删除index的第一个元素并在此位置添加&#39;x&#39;</code></li><li><code>arr.splice(index,1,&#39;x&#39;,&#39;y&#39;)//删除index的第一个元素并在此位置添加&#39;x&#39;,&#39;y&#39;</code></li><li>此方法会修改原数组</li></ul></li></ul></li></ul><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ul><li>使用 for 循环<ul><li><code>for（let i = 0;i &lt; arr.length;i++ ）&#123;...&#125;</code></li></ul></li><li>使用 forEach<ul><li><code>arr.forEach(function(item,index,arr)&#123;...&#125;)</code></li><li>和 for 的对比</li><li>首先：for 循环里面是有 break，continue 等方法的，forEach 是没有的</li><li>其次：for 是一个关键字，里面的是一个块作用域，而 forEach 是一个函数，里面的是一个函数作用域</li></ul></li><li>查看单个属性<ul><li>使用下表读取，a[1]，注意此时 1 会在 JS 内部被强制转化成字符串形式<ul><li>索引越界问题<ul><li>读取了 length 的属性就会越界，因为 undefine 不能使用 testing()方法，所以此时会报错，一定要注意这一点</li></ul></li></ul></li><li>查看单个元素是否存在<ul><li><code>arr.indexOf(item) //存在返回index，不存在返回-1</code></li></ul></li><li>使用条件查找元素<ul><li><code>arr.find(item=&gt;item%2 === 0)//找第一个偶数</code></li></ul></li><li>使用条件查找元素的索引<ul><li><code>arr.findindex(item=&gt;item%2===0))//找第一个2偶数的索引</code></li></ul></li></ul></li></ul><h2 id="数组元素的增加"><a href="#数组元素的增加" class="headerlink" title="数组元素的增加"></a>数组元素的增加</h2><ul><li>在尾部添加元素<ul><li>arr.push(newitem) &#x2F;&#x2F;修改 arr，返回新长度</li><li>arr.push(item1,item2)&#x2F;&#x2F;修改 arr，返回新长度</li></ul></li><li>在头部添加元素<ul><li>arr.unshift(newitem) &#x2F;&#x2F;修改 arr，返回新长度</li><li>arr.unshift(item1,item2)&#x2F;&#x2F;修改 arr，返回新长度</li></ul></li><li>在中间添加元素<ul><li>arr.splice(index,0,’x’ )&#x2F;&#x2F; 在 index 除插入’x’</li><li>arr.splice(index,0,’x’ ,’y’)&#x2F;&#x2F; 在 index 除插入’x’,’y’</li></ul></li></ul><h2 id="反转顺序"><a href="#反转顺序" class="headerlink" title="反转顺序"></a>反转顺序</h2><ul><li>反转数组<ul><li>arr.reverse() &#x2F;&#x2F;会修改原数组<ul><li>反转一个字符串 <code>string.split(&#39; &#39;).reverse().join(&#39; &#39;)</code></li></ul></li><li>自定义顺序<ul><li>Arr.sort((a,b)&#x3D;&gt;a-b)</li></ul></li></ul></li></ul><h2 id="数组的变换"><a href="#数组的变换" class="headerlink" title="数组的变换"></a>数组的变换</h2><ul><li>map() n 变 n</li><li>filter() n 变少</li><li>reduce() n 变 1</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS 对象基本用法</title>
    <link href="/2021/09/17/JS%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2021/09/17/JS%20%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ul><li><p>定义</p><ul><li>无需的数据集合</li><li>键值对的集合</li></ul></li><li><p>如何声明</p><ul><li>字面量 <code>let i = &#123;&#125;</code></li><li>使用 Object 构造函数 <code>let i = new Object()</code></li></ul></li><li><p>值得注意的细节</p><ul><li><strong>键名是字符串</strong>，不是<strong>标志符</strong>，可以包含任意字符</li><li>引号可以省略，省略之后只可以写标志符</li><li>即便是省略之后键名也还是字符串</li><li>除了字符串之外，symbol 也能做属性名，一般用在迭代上，目前比较少见</li></ul></li><li><p>变量的值做属性名</p><ul><li>使用[变量]就会使用使用变量的值作为键值，如果变量值是除 symbol 意外的其他类型，则会自动变成字符串</li></ul></li><li><p>删属性</p><ul><li>delete obj.xxx 或 delete obj[‘xxx’] 注意与 obj.xxx &#x3D; undefined 的区别，后者只是将值设置为 undefined,而键名还在</li></ul></li><li><p>读属性</p><ul><li>查看自身所有属性：Object.keys(obj)</li><li>查看自身所有值：Object.values(obj)</li><li>查看自生加共有属性：<ul><li>console.dir(obj)</li><li>或者使用自己用 Object.keys()打印 proto</li></ul></li><li>判断一个属性是自有的还是共有的<ul><li>obj.hasOwnProperty(‘tostring’)，注意与’name’ in obj 的区别，后者判断对象中是否由属性时，若自身没有，在原型中找到也是返回 true，而前者只有自身有才返回 true</li></ul></li></ul></li><li><p>查属性</p><ul><li>两种方法<ul><li>中括号语法：obj[‘key’]</li><li>点语法：obj.key</li></ul></li></ul></li><li><p>修改或者增加属性</p><ul><li>直接赋值</li><li>批量赋值<ul><li>object.assign(),例如 Object.assign(obj, {age: 18, gender: ‘man’})</li></ul></li><li>修改原型对象<ul><li>Object.prototype.toString &#x3D; ‘xxx’ ，一般来说，不要修改原型，会引起很多问题</li></ul></li><li>替换原型对象<ul><li>推荐使用 Object.create 不推荐直接修改 proto，例如<code>let obj = Object.create(common)</code></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js基本数据类型定义以及转换</title>
    <link href="/2021/09/12/js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2/"/>
    <url>/2021/09/12/js%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h2><ul><li><p>ASCⅡ 码表</p><ul><li><p>0 表示结束字符</p></li><li><p>10 表示换行</p></li><li><p>13 表示回车</p></li><li><p>32 表示空格</p></li><li><p>33 到 47 表示标点</p></li><li><p><strong>48 到 57 表示数字符号</strong></p></li><li><p><strong>65 到 90 表示大写字母</strong></p></li><li><p><strong>97 到 122 表示小写字母</strong></p></li><li><p>127 表示删除键</p></li><li><p>详细码表可以搜索得到，需要记住的是数字从 48 开始，大写字母在小写字母前面</p></li></ul></li><li><p>unicode 编码</p><ul><li>UTF-8 中的 8 是指最少可以用 8 位存一个字符</li></ul></li></ul><h2 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h2><ul><li><p>8 种数据类型</p><ul><li><p>7 种基本（原始）数据类型</p><ul><li><p>Number</p><ul><li>64 位浮点数</li><li>0 +0 -0 都等于零</li><li>infinite 、+ infinite 、- infinite</li><li>NaN 表示不能表示的数字，但是<strong>NaN 是数字类型</strong><ul><li>0&#x2F;0 等于 NaN</li><li>NaN 不等于 NaN</li></ul></li><li>范围<ul><li>Number.MAX_VALUE: 1.7976931348623157e+308</li><li>Number.MIN_VALUE: 5e-324</li></ul></li><li>精度<ul><li>最多只能到 52+1 个二进制位表示有效数字</li><li>2^53 对应的十进制是 9 后面 15 个零</li><li>所以 15 位有效数字都能精确表示</li><li>16 位有效数字如果小于 90 开头，也能精确表示</li><li>9110000000000001 就存不下来</li></ul></li></ul></li><li><p>String</p><ul><li><p>每个字符只用两个字节（阉割版 utf8）</p></li><li><p>写法</p><ul><li><p>“”</p></li><li><p>‘’</p></li><li><p>&#96;&#96; (模版字符串)</p></li><li><p>注意<strong>转义字符</strong></p><p><img src="/images/pic14(%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6).png" alt="pic14(转义字符)"></p></li><li><p>属性</p><ul><li>.length</li></ul></li><li><p>base64 转码</p><ul><li>window.btoa() 加密</li><li>window.atob()解密</li><li>太简单了要少用</li></ul></li></ul></li></ul></li><li><p>Boolean</p><ul><li><strong>5 个 falsy</strong><ul><li>Null</li><li>undefinde</li><li>0</li><li>NaN</li><li>‘’</li></ul></li></ul></li><li><p>Null</p></li><li><p>Undefined</p></li><li><p>Sybol</p></li><li><p>Bigint(2020 年 6 月新加入)</p></li></ul></li><li><p>复杂数据类型：Object</p></li></ul></li><li><p>类型转换</p><ul><li>Number&#x3D;&gt;string<ul><li>String(n)</li><li>n+’’</li></ul></li><li>String&#x3D;&gt;Number<ul><li>Number(s)</li><li>ParsInt(s)&#x2F;ParsFloat(s)</li><li>s - 0 &#x2F; + s</li></ul></li><li>x &#x3D;&gt;boolean<ul><li>Bolean(x)</li><li>!!x</li></ul></li><li>x &#x3D;&gt;string<ul><li>String(x);</li><li>x.toString();</li></ul></li></ul></li></ul><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><ul><li><p>var</p></li><li><p>let</p><ul><li><strong>块作用域</strong></li><li><strong>没有变量提升</strong>，不可重复赋值，必须先声明再使用，否则报错</li><li>可以赋值，也可以不赋值</li><li><strong>全局声明的 let，不会变成 window 的属性</strong></li><li>for 里面使用 let 有奇效</li></ul></li><li><p>const</p><ul><li>块作用域</li><li><strong>没有变量提升</strong>，有且仅有一次赋值，必须先声明再使用，否则报错</li><li><strong>声明时必须赋值，而且不可改</strong></li><li><strong>全局声明的 const，不会变成 window 的属性</strong></li></ul><p>阅读材料<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/">JavaScript 秘密花园 (bonsaiden.github.io)</a></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js语法</title>
    <link href="/2021/09/07/js%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/09/07/js%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h2><ul><li>表达式会产生一个值，它可以放在任何需要一个值的地方，比如作为一个函数调用的参数</li><li>语句可以理解为一种行为，比如循环语句和 if 语句就是典型的语句</li><li>区别<ul><li>表达式一般有值，语句可能有也可能没有</li><li>语句一般会改变环境（比如声明，赋值）</li><li>当然以上两句并非绝对</li></ul></li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li>第一个字符，可以是 Unicode 字母或 $ 或 _ 或中文</li><li>后面的字符除了以上提到的还可以使用数字（<strong>首个字符不可以数字</strong>）</li></ul><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><ul><li>语法<ul><li>if(表达式){语句 1}else{语句 2}</li><li>{}在语句只有一句的时候可以省略</li></ul></li><li>变态情况<ul><li>if 之后表达式的问题，有时候会写错成语句比如 a&#x3D;1 这样</li><li>if 的嵌套问题</li><li>缩进的问题</li></ul></li></ul><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><ul><li><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (fruit) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;banana&#x27;</span>:<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;apple&#x27;</span>:<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意 break 的作用</p></li></ul><h2 id="短路逻辑"><a href="#短路逻辑" class="headerlink" title="短路逻辑"></a>短路逻辑</h2><ul><li>A &amp;&amp; B<ul><li>如果 A 为真，执行 B</li><li>如果 A 为假，执行 A</li></ul></li><li>A || B<ul><li>如果 A 为真，执行 A</li><li>如果 A 为假，执行 B</li></ul></li></ul><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><ul><li>语法<ul><li>while (表达式){语句}</li><li>判断表达式的真假</li><li>为真执行语句，再次判断表达式</li><li>为假执行之后语句</li></ul></li><li>do…while 会先执行一次再判断</li><li>判断时要注意 JS 中浮点数问题，在 JS 中 0.1+0.2 不等于 0.3（控制台可试）</li></ul><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><ul><li><p>语法</p><ul><li><p>for(语句 1;表达式 2;语句 3){循环体}</p></li><li><p>先执行表达式 1</p></li><li><p>然后判断表达式 2</p></li><li><p>为真，执行循环体，然后执行语句 3</p></li><li><p>为假，直接退出循环，执行后面的语句</p></li><li><p>经典题目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//问：输出是什么</span><br></code></pre></td></tr></table></figure><p>答案是 5 个 5，关键点是 setTimeout 是一个异步函数，这里如果使用 let 就是 0 到 4 了（利用了 let 块级作作用域）</p></li></ul></li></ul><h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><ul><li>break 会退出所有循环</li><li>continue 会退出当前一次的循环</li></ul><h2 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a>label 语句</h2><ul><li><p>是一个标签，在代码执行时可以实现跳转等功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时这是一个代码块，a 是一个 label ，里面的语句是 1</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js引擎及原型链基础</title>
    <link href="/2021/09/04/js%E5%BC%95%E6%93%8E%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/09/04/js%E5%BC%95%E6%93%8E%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="内存图与-JS-世界"><a href="#内存图与-JS-世界" class="headerlink" title="内存图与 JS 世界"></a>内存图与 JS 世界</h2><h3 id="浏览器的功能："><a href="#浏览器的功能：" class="headerlink" title="浏览器的功能："></a>浏览器的功能：</h3><ul><li>发起请求，下载 HTML，解析 HTML，下载 CSS，解析 CSS，<strong>渲染界面</strong>，下载 JS，解析 JS，执行 JS 等</li><li>功能模块：用户模块，<strong>渲染引擎</strong>，<strong>JS 引擎</strong>等</li><li>上述功能模块处于不同的<strong>线程</strong>，<strong>线程</strong>比<strong>进程</strong>更小一级</li></ul><h3 id="JS-引擎"><a href="#JS-引擎" class="headerlink" title="JS 引擎"></a>JS 引擎</h3><blockquote><p>Chrome 和 Nodejs 使用的是 V8 引擎，C++编写</p></blockquote><ul><li>主要功能<ul><li>编译：编译 JS 代码，把 JS 翻译成字节码或者机器码</li><li>优化：改写代码，使其更高效</li><li>执行：执行上面的字节码或者机器码</li><li>垃圾回收：内存回收</li></ul></li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>准备工作</p><ul><li><p>（浏览器）提供 API：window &#x2F; document &#x2F; setTimeout</p></li><li><p>这些都不是 Js 提供的，而是浏览器提供的</p></li><li><p>我们把这些功能称为运行环境（runtime env）</p></li><li><p>一旦 JS 放入页面，就开始执行 JS</p></li><li><p>内存分配</p><blockquote><p><img src="/img/pic11.png" alt="pic11"></p><p><img src="/img/pic12.png" alt="pic12"></p><p>数据分为两种：对象和非对象</p><p>非对象存在栈，对象存在堆里面</p><p>&#x3D;总是会把右边的值复制给左边（所以这里不存在什么按值传递和按地址传递）</p></blockquote></li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="/img/pic13.png" alt="pic13">很熟悉了，直接上图</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript的诞生及发展</title>
    <link href="/2021/09/03/javascript%E7%9A%84%E8%AF%9E%E7%94%9F%E5%8F%8A%E5%8F%91%E5%B1%95/"/>
    <url>/2021/09/03/javascript%E7%9A%84%E8%AF%9E%E7%94%9F%E5%8F%8A%E5%8F%91%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>JavaScript 因为互联网而生，紧随着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。</p><p>此处我们使用时间线的形式，简单回顾这段辉煌的历史：</p><ul><li><p>1990 年底，欧洲核能研究组织，发明了万维网（World Wide Web）。</p></li><li><p>1992 年底，美国国家超级电脑应用中心（NCSA），开发了第一个浏览器，Mosaic。</p></li><li><p>1994 年 10 月，Mosaic 通信公司成立，不久后改名为 Netscape。开始开发面向普通用户的新一代的浏览器 Netscape Navigator。</p></li><li><p>1994 年 12 月，Navigator 发布了 1.0 版，市场份额一举超过 90%。</p><blockquote><p>Netscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为（表单验证）。管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习和部署。<br>那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。<br>但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。</p></blockquote></li><li><p>1995 年，Netscape 公司雇佣了程序员<strong>Brendan Eich</strong>开发这种网页脚本语言。</p><blockquote><p>但是，他对 Java 一点兴趣也没有。为了应付公司安排的任务，他只用 10 天时间就把 Javascript 设计出来了。</p><p>由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript 写出来的程序混乱不堪。如果 Brendan Eich 预见到，未来这种语言会成为互联网第一大语言，全世界有几百万学习者，他会不会多花一点时间呢？</p><p>总的来说，他的设计思路是这样的：</p><p>（1）借鉴 C 语言的基本语法；</p><p>（2）借鉴 Java 语言的数据类型和内存管理；</p><p>（3）借鉴 Scheme 语言，将函数提升到”第一等公民”（first class）的地位；</p><p>（4）借鉴<a href="https://en.wikipedia.org/wiki/Self_(programming_language)">self 语言</a>，使用基于原型（prototype）的继承机制。</p><p>在名称方面，JavaScript 一开始被命名为 Mocha（摩卡），然后经历了 Mocha&#x3D;&gt;LiveScriot&gt;JavaScript 的过程。</p></blockquote></li><li><p>1996 年 8 月互联网巨头微软公司进入浏览器领域，推出 JScript，和 NetScript 公司开始争夺博主地位。同年 11 月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association）</p><blockquote><p>希望 JavaScript 能够成为国际标准，以此抵抗微软。</p></blockquote></li><li><p>1997 年 7 月，ECMA 组织发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。</p><blockquote><p>之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。</p></blockquote></li></ul><h2 id="JavaScript-的兴起"><a href="#JavaScript-的兴起" class="headerlink" title="JavaScript 的兴起"></a>JavaScript 的兴起</h2><ul><li>2004 年愚人节时，杀手级应用 Gmail 出现，之前人们认为网页只能看新闻和图片，Gmail 的出现让用户和开发者眼前一亮</li><li>2005 年，Jesse 将谷歌用到的技术命名为 AJAX，从此前端技术正式出现。在此之前网页开发是后端设计师完成。</li><li>2006 年，JQuery 发布，目前最长寿的 JS 库，后十年 JQuery 大放异彩，直到 IE 不行了，JQuery 才稍微降温。（JQuery 能让代码在 IE、Firefox、谷歌等都不报错）</li></ul><h2 id="JavaScript-的爆发"><a href="#JavaScript-的爆发" class="headerlink" title="JavaScript 的爆发"></a>JavaScript 的爆发</h2><ul><li>V8 引擎<ul><li>Chrome 的 JS 引擎是 V8</li><li>2009 年，Ryan 基于 V8 创建了 Node.js</li><li>2010 年，Isaac 基于 Node.js 写了 npm</li><li>至此，js 可以脱离浏览器运行了</li><li>2010 年，TJ 受到 Sinatra 启发，发布了 Express.js。用它可以代替 java 等做一个后端完整的服务器</li><li>爆发：React、VUE 等出现</li></ul></li></ul><h2 id="ECMAScript-版本发展"><a href="#ECMAScript-版本发展" class="headerlink" title="ECMAScript 版本发展"></a>ECMAScript 版本发展</h2><ul><li>时间线：<ul><li>1997 年 6 月，第一版 ECMAScript 发布</li><li>1999 年 12 月，第三版发布，该版使用最广泛</li><li>第四版，流产</li><li>2009 年 12 月，第五版发布，增加了一些功能</li><li>2015 年 6 月，第六版发布，新浏览器都支持这一版本，之后每年发布一版，版本号以年份命名<ul><li>JS 与 ECMAScript 关系：<br>ECMAScript 写在纸上的标准，JS 是浏览器实现<br>纸上标准落后于浏览器，先实现再写进标准</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP请求响应&amp;node入门</title>
    <link href="/2021/09/01/%20http%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94&amp;node%E5%85%A5%E9%97%A8/"/>
    <url>/2021/09/01/%20http%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94&amp;node%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>服务器端代码部分逻辑</p><ul><li><p>每次收到请求都会把中间的代码执行一遍</p></li><li><p>用 if else 判断路径，并返回响应</p></li><li><p>如果是已知路径，一律返回 200</p></li><li><p>如果是未知路径，一律返回 404</p></li><li><p><strong>Content-Type 表示内容的「类型&#x2F;语法」,与路径里面的无关</strong></p></li><li><p>response.write() 可以填写返回的内容</p></li><li><p>response.end() 表示响应可以发给用户了</p></li></ul></li></ul><h2 id="HTTP-请求与相应基础"><a href="#HTTP-请求与相应基础" class="headerlink" title="HTTP 请求与相应基础"></a>HTTP 请求与相应基础</h2><ul><li><p>请求</p><ul><li><p><strong>请求动词 路径加请求参数 协议名&#x2F;版本</strong></p></li><li><p>HOST：域名或者 IP</p></li><li><p>User Agent：用户代理（User Agent）就是帮你发送请求的工具，使用浏览器时浏览器就是用户代理，使用 curl 时 curl 就是用户代理</p></li><li><p>Accept：text&#x2F;html，表示接受什么内容</p></li><li><p><strong>content-type：请求体的格式</strong></p></li><li><p>回车</p></li><li><p>请求体</p></li><li><p>细节问题</p><ul><li>三部分：请求行（第一行），请求头（第二到第五行 ），请求体</li><li>请求动词有：GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;PATCH 等</li><li>请求体一般在 GET 请求中为空</li><li>文档查阅 RFC2616 第五章</li></ul></li></ul></li><li><p>响应</p><ul><li><strong>协议名&#x2F;版本 状态码 状态字符串</strong></li><li><strong>content-type：响应体的格式</strong></li><li>回车</li><li>响应体</li><li>细节问题<ul><li>三部分 状态行，响应头，响应体</li><li>常见状态码是面试常问的问题</li><li>文档查阅 RFC2616 第六章</li></ul></li></ul></li></ul><h2 id="CURL-构造-HTTP-请求"><a href="#CURL-构造-HTTP-请求" class="headerlink" title="CURL 构造 HTTP 请求"></a>CURL 构造 HTTP 请求</h2><ul><li><p>以上内容使用<code>curl -v www.baidu.com</code>就可以对照找出相应内容</p></li><li><p>设置请求动词</p><ul><li>-X POST</li><li>注意大小写</li></ul></li><li><p>设置路径和参数</p><ul><li>直接在 URL 后面写</li></ul></li><li><p>设置请求头</p><ul><li>-H ‘Name:Value’ or –header ‘Name:Value’</li></ul></li><li><p>设置请求体</p><ul><li>-d ‘content’ or –data ‘content’</li></ul><p><img src="/img/pic9.png" alt="pic9"></p><p><img src="/img/pic10.png" alt="pic10"></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>Node</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析URL</title>
    <link href="/2021/08/30/%20%E6%B5%85%E6%9E%90URL/"/>
    <url>/2021/08/30/%20%E6%B5%85%E6%9E%90URL/</url>
    
    <content type="html"><![CDATA[<p>URL（Uniform Resource Locator）即<strong>统一资源定位符</strong>，它是 WWW 的统一资源定位标志，就是指网络地址。这里需要和另外一个概念 URI（Uniform Resource Identifier）即<strong>统一资源标识符</strong>区分开，URI 是一个用于标识某一互联网资源名称的字符串，URL 是 URI 的子集。</p><p>url 的组成包括以下内容：</p><ul><li><p>协议（必须）：常见的有 HTTP（Hyper Text Transfer Protocol）、HTTPS、FTP 等，</p></li><li><p>域名&#x2F;IP（必须）：域名通过 DNS 被解析成 IP</p><ul><li>域名（Domain Name）<ul><li>域名分类：.xxx 如.com、.net、.cn 等是<strong>顶级域名</strong>，xxx.xxx 是<strong>二级域名</strong>（俗称一级域名），<a href="http://www.xxx.xxx是**三级域名**(俗称二级域名),所以xxx.xxx与www.xxx.xxx可能不是同一个网站/">www.xxx.xxx是**三级域名**（俗称二级域名），所以xxx.xxx与www.xxx.xxx可能不是同一个网站</a></li></ul></li><li>IP 即 IP 地址（Internet Protocol Address），<ul><li>mac 查询内网 IP <code>ifconfig en0</code>,查询外网 IP<code>curl ifconfig.me</code></li><li>ping 用于确定本地主机是否能与另一台主机成功交换(发送与接收)数据包，再根据返回的信息，就可以推断 TCP&#x2F;IP 参数是否设置正确，以及运行是否正常、网络是否通畅等。用法<code>ping xxx</code></li><li>几个特殊的 IP<ul><li>127.0.0.1 表示自己</li><li>localhost 通过 hosts 指定为自己（mac 的 hosts 位于<code>/etc/hosts</code>，可通过修改该文件自定义 localhost 名称）</li></ul></li></ul></li><li>DNS （Domain Name System 域名系统），实现域名到 IP 的解析服务<ul><li>使用<code>nslookup 域名</code>可以手动进行 DNS 查询</li></ul></li><li>一个域名可以对应不同 IP（实现负载均衡）；一个 IP 也可以对应不同域名（共享主机）</li></ul></li><li><p>端口（必须，如省略会使用默认端口）</p><ul><li>一共有 65535 个端口，0 到 1023（2 的十次方减 1）号端口是留给系统使用的，只有在有管理员权限的情况下才可以使用，其他端口普通用户能使用，比如 http-server 就默认使用 8080 端口，详见：<a href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0.E5.88.B01023.E5.8F.B7.E7.AB.AF.E5.8F.A3">TCP&#x2F;UDP 端口列表 - 维基百科</a></li><li><strong>HTTP 最好使用 80 端口</strong></li><li><strong>HTTPS 最好使用 443 端口</strong></li><li><strong>FTP 最好使用 21 端口</strong></li></ul></li><li><p>路径（非必需）</p><p>实现请求不同的页面</p></li><li><p>查询参数（非必需）</p><ul><li>从“？”开始到“#”（或至结束）为止之间的部分为参数部分，又称搜索部分、查询部分。参数间用“&amp;”作为分隔符。</li></ul></li><li><p>锚点（非必需）</p><p>实现打开页面时滚动到该锚点位置。</p><ul><li>锚点看起来有中文，但是实际上不支持中文，</li><li>锚点无法在 network 面板看到，因为<strong>锚点不会传给服务器也就是说 HTTP 请求中不包含锚部分</strong></li></ul></li></ul><h2 id="使用-curl-命令进行-HTTP-请求"><a href="#使用-curl-命令进行-HTTP-请求" class="headerlink" title="使用 curl 命令进行 HTTP 请求"></a>使用 curl 命令进行 HTTP 请求</h2><ul><li>curl -v <a href="http://baidu.com/">http://baidu.com</a></li><li>curl -s -v <a href="https://www.baidu.com/">https://www.baidu.com</a></li><li>curl 会重写 url，先请求 DNS 获取 IP</li><li>过程：进行 TCP 连接，TCP 连接成功后，开始发 HTTP 请求，相应结束后，关闭 TCP 连接</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS动画</title>
    <link href="/2021/08/15/css%E5%8A%A8%E7%94%BB%202/"/>
    <url>/2021/08/15/css%E5%8A%A8%E7%94%BB%202/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ul><li><p>根据 HTML 构筑 HTML 树（DOM）</p></li><li><p>根据 CSS 构筑 CSS 树（CSSDOM）</p></li><li><p>将两棵树合并成一棵渲染树（render tree）</p><p><img src="/img/pic5.png" alt="pic5"></p></li><li><p>LAYOUT 布局（文档流、盒模型、计算大小和位置）</p></li><li><p>paint 绘制（把边框颜色、文字颜色、阴影等画出来）</p></li><li><p>composite 合成（根据层叠关系展示画面）</p></li><li><p>三种更新方式</p><p><img src="/img/pic6.png" alt="pic6"></p><ol><li><p>例如 div.remove()全部走一遍</p></li><li><p>改变 background，没有 layout 一步</p></li><li><p><strong>transform 只需要 composite，不需要 reflow 和 repaint，所以相对来说在性能上更优</strong></p><p> reflow 在布局发生变化之后进行，而 repaint 仅在例如背景颜色和边框颜色等没有发生布局变化的情况下进行，优化 reflow 和 repaint 可以 GOOGLE。</p></li><li><p>每个属性都触发什么渲染流程可以参考此网站：<a href="https://csstriggers.com/">CSS Triggers</a></p></li><li><p>关于 CSS 动画的优化，详见：<a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count#%E7%AE%A1%E7%90%86%E5%B1%82%E5%B9%B6%E9%81%BF%E5%85%8D%E5%B1%82%E6%95%B0%E6%BF%80%E5%A2%9E">坚持仅合成器的属性和管理层计数 | Web | Google Developers</a></p><p> <img src="/img/pic7.png" alt="pic7"></p></li></ol></li></ul><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>inline 元素不支持 transform，需要先转成 block，具体语法可以直接看 MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">transform - CSS（层叠样式表） | MDN (mozilla.org)</a></p><ul><li>translate 位移<ul><li>绝对定位和 translate(-50%,-50%)配合使用可以实现元素的居中</li></ul></li><li>scale 缩放</li><li>rotate 旋转</li><li>skew 倾斜</li></ul><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>过渡，补充中间帧</p><ul><li><p>transition:属性 时长 过渡方式 延迟</p></li><li><p>多个属性用逗号隔开</p></li><li><p>all 表示所有属性</p></li><li><p>过渡方式有很多，默认是 ease，具体查 MDN</p></li><li><p>注意点</p><ul><li>并非所有属性都可以过渡，比如 display：none&#x3D;&gt;block 就不能过渡，可以使用 visibility：hidden&#x3D;&gt;visible,关于这两者的区别就是 display：none 的元素从文档流中消失了，而 visibility：hidden 则是文档流中保留原占据空间，知识看不见了</li><li>颜色和透明度都是可以过渡的</li><li>过渡必须要有起始状态和结束状态</li></ul></li><li><p>如果有两次过渡怎么办？</p><p><img src="/img/pic8.png" alt="pic8"></p></li></ul><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><ul><li><p>Animation 语法</p><p>详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation">animation - CSS（层叠样式表） | MDN (mozilla.org)</a></p><ul><li>anmition：时长｜过渡方式｜延迟｜次数｜方向｜填充方式｜是否暂停｜动画名</li><li>属性次序不是固定的</li><li>动画结束后停在最后一帧可以将填充模式设置为 forwards 即可</li><li>无限回环动画可以将属性设置为 alternate infinite</li></ul></li><li><p>@keyframes</p><p>详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes">@keyframes - CSS（层叠样式表） | MDN (mozilla.org)</a></p><ul><li>@keyframes XXX { }</li><li>可以使用 from to 或者是百分比</li></ul></li></ul><p>本次实践写在 <a href="http://js.jirengu.com/mihunawoci/5/edit">饥人谷 JS Bin (jirengu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS动画</title>
    <link href="/2021/08/15/css%E5%8A%A8%E7%94%BB/"/>
    <url>/2021/08/15/css%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><ul><li><p>根据 HTML 构筑 HTML 树（DOM）</p></li><li><p>根据 CSS 构筑 CSS 树（CSSDOM）</p></li><li><p>将两棵树合并成一棵渲染树（render tree）</p><p><img src="/img/pic5.png" alt="pic5"></p></li><li><p>LAYOUT 布局（文档流、盒模型、计算大小和位置）</p></li><li><p>paint 绘制（把边框颜色、文字颜色、阴影等画出来）</p></li><li><p>composite 合成（根据层叠关系展示画面）</p></li><li><p>三种更新方式</p><p><img src="/img/pic6.png" alt="pic6"></p><ol><li><p>例如 div.remove()全部走一遍</p></li><li><p>改变 background，没有 layout 一步</p></li><li><p><strong>transform 只需要 composite，不需要 reflow 和 repaint，所以相对来说在性能上更优</strong></p><p> reflow 在布局发生变化之后进行，而 repaint 仅在例如背景颜色和边框颜色等没有发生布局变化的情况下进行，优化 reflow 和 repaint 可以 GOOGLE。</p></li><li><p>每个属性都触发什么渲染流程可以参考此网站：<a href="https://csstriggers.com/">CSS Triggers</a></p></li><li><p>关于 CSS 动画的优化，详见：<a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count#%E7%AE%A1%E7%90%86%E5%B1%82%E5%B9%B6%E9%81%BF%E5%85%8D%E5%B1%82%E6%95%B0%E6%BF%80%E5%A2%9E">坚持仅合成器的属性和管理层计数 | Web | Google Developers</a></p><p> <img src="/img/pic7.png" alt="pic7"></p></li></ol></li></ul><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>inline 元素不支持 transform，需要先转成 block，具体语法可以直接看 MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">transform - CSS（层叠样式表） | MDN (mozilla.org)</a></p><ul><li>translate 位移<ul><li>绝对定位和 translate(-50%,-50%)配合使用可以实现元素的居中</li></ul></li><li>scale 缩放</li><li>rotate 旋转</li><li>skew 倾斜</li></ul><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p>过渡，补充中间帧</p><ul><li><p>transition:属性 时长 过渡方式 延迟</p></li><li><p>多个属性用逗号隔开</p></li><li><p>all 表示所有属性</p></li><li><p>过渡方式有很多，默认是 ease，具体查 MDN</p></li><li><p>注意点</p><ul><li>并非所有属性都可以过渡，比如 display：none&#x3D;&gt;block 就不能过渡，可以使用 visibility：hidden&#x3D;&gt;visible,关于这两者的区别就是 display：none 的元素从文档流中消失了，而 visibility：hidden 则是文档流中保留原占据空间，知识看不见了</li><li>颜色和透明度都是可以过渡的</li><li>过渡必须要有起始状态和结束状态</li></ul></li><li><p>如果有两次过渡怎么办？</p><p><img src="/img/pic8.png" alt="pic8"></p></li></ul><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><ul><li><p>Animation 语法</p><p>详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation">animation - CSS（层叠样式表） | MDN (mozilla.org)</a></p><ul><li>anmition：时长｜过渡方式｜延迟｜次数｜方向｜填充方式｜是否暂停｜动画名</li><li>属性次序不是固定的</li><li>动画结束后停在最后一帧可以将填充模式设置为 forwards 即可</li><li>无限回环动画可以将属性设置为 alternate infinite</li></ul></li><li><p>@keyframes</p><p>详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes">@keyframes - CSS（层叠样式表） | MDN (mozilla.org)</a></p><ul><li>@keyframes XXX { }</li><li>可以使用 from to 或者是百分比</li></ul></li></ul><p>本次实践写在 <a href="http://js.jirengu.com/mihunawoci/5/edit">饥人谷 JS Bin (jirengu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2021/08/10/css/"/>
    <url>/2021/08/10/css/</url>
    
    <content type="html"><![CDATA[<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><ul><li>最广泛的版本 CSS2.1，最新版本 CSS3（分块升级）</li><li>判断浏览器支持 CSS 情况，<a href="http://www.caniuse.com/">CAN I use</a></li><li>标准的制定者是 W3C，搜索 CSS3 spec 可以找到并查看最新标准，目前 CSS2.1 有人工翻译的版本可供查阅参考</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><p>选择器 {</p><p>属性名：属性值;</p><p>&#x2F;_ 注释 _&#x2F;</p><p>}</p></li><li><p>at 语法</p><p>@charset “UTF-8”;</p><p>@import url(“2.css”); 这个是 CSS 语法</p><ul><li>@import “2.css”; 与@import url(“2.css”);一样</li><li>最后的分号必不可少</li><li>必须放在 CSS 文件开头</li><li>效率一般，没有 JS 模块快和灵活，所以用的比较少</li></ul><p>@media(min-width:100px) and (max-width:200px) {</p><p>语法一</p><p>}</p><ul><li>@charset 必须放在第一行</li><li>前两个 at 语法必须以;结束</li><li>charset 是字符集，但 UTF-8 是字符编码 encoding，这是历史遗留问题，这里确定的是 <strong>文件编码</strong></li></ul></li></ul><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><ul><li>流动方向<ul><li>inline 元素从左往右，到最右边换行</li><li>block 元素从上往下，每一个都另起一行</li><li>inline-block 也是从左往右</li></ul></li><li>宽度<ul><li>inline 宽度为内部 inline 元素的和，不能用 width 指定</li><li>block 默认自动计算宽度(<strong>这里需要说明一点就是自动就算宽度不代表就是 100%，指的是填充满，比如有边框的情况，任何尽量不要让宽度设置为 100%</strong>)，可与 width 指定</li><li>inline- block 结合前两者特点，可用 width</li></ul></li><li>高度<ul><li><strong>inline 高度由 line- height 间接确定</strong>，和 height 无关</li><li>block 高度由内部文档流元素决定，可以是设 height</li><li>Inline-block 和 block 类似，可以设置 height</li></ul></li><li>脱离文档流<ul><li>浮动 定位</li></ul></li></ul><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><ul><li><p>两个模型</p><ul><li>分别是什么<ul><li>content-box 内容盒 width 只包含 content 的宽度</li><li>border-box 边框盒 width 包含 border、padding、border 的宽度</li></ul></li><li>公式<ul><li>content-box width &#x3D; 内容宽度</li><li>border-box width &#x3D; 内容宽度+padding _ 2+border _ 2</li></ul></li></ul></li><li><p>margin 合并（<strong>只发生在上下 margin</strong>）</p><ul><li>那些情况会合并，<ul><li>兄弟 margin 合并</li><li>父子 margin 合并</li></ul></li><li>如何阻止合并<ul><li>兄弟合并是符合预期的</li><li>兄弟合并可以用 inline- block 消除</li><li>父子合并解决<ul><li>父元素设置 border&#x2F;padding</li><li>父元素设置 overflow:hidden</li><li>display:flex</li></ul></li></ul></li></ul></li></ul><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><ul><li>长度单位<ul><li>px</li><li>em 相对于自身 font-size 的倍数</li><li>百分数</li><li>整数</li><li>rem</li><li>vw,vh</li></ul></li><li>颜色<ul><li>十六进制</li><li>RGBA</li><li>HSL 颜色</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局</title>
    <link href="/2021/08/10/csslayout/"/>
    <url>/2021/08/10/csslayout/</url>
    
    <content type="html"><![CDATA[<h2 id="何为布局"><a href="#何为布局" class="headerlink" title="何为布局"></a>何为布局</h2><p>把页面分成一块块的，按左中右，上中下等排列</p><ul><li>两种<ul><li>固定宽度布局，一般宽度为 960&#x2F;1000&#x2F;1024px</li><li>不固定宽度布局，主要靠文档流的原理来布局</li></ul></li><li>第三种布局<ul><li>响应式布局</li><li>PC 上固定宽度，手机上不固定宽度</li><li>也就是一种混合布局</li></ul></li><li>布局思路<ul><li>从大到小</li><li>从小到大</li></ul></li></ul><h2 id="选择布局方式"><a href="#选择布局方式" class="headerlink" title="选择布局方式"></a>选择布局方式</h2><p><img src="/img/pic2.png" alt="图解"></p><ul><li><p>float 布局</p><ul><li><p>步骤</p><ul><li>子元素添加 float 标签</li><li><strong>父元素清除浮动，加上.clearfix</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>经验</p><ul><li>有经验的人会留一些空间，或者最后一个不设 width</li><li><strong>不需要做响应式，此布局方法是为 IE 准备的</strong></li><li>此方法在 IE6&#x2F;7 上有双倍 margin 的 BUG<ul><li>解决方法 1:针对浏览器将 margin 减半，margin 后面加一句_margin&#x3D;xxx 覆盖之前设置的</li><li>加一句 display：inline-block</li></ul></li></ul></li><li><p>在 float 平均布局中会遇到容器盒子宽度不够导致溢出的问题，这时候可以使用<strong>负 margin 法</strong>来进行解决，具体方法可以解释为再加一层盒子嵌套，然后在该盒子上把对应的 margin 设为负值</p></li></ul></li><li><p>flex 布局</p><ul><li><p>container</p><ul><li><p>把一个元素变成 flex 布局：</p><ul><li><code>display:flex</code></li><li><code>display:inlineflex</code></li></ul></li><li><p>改变 items 流动方向（主轴）</p><ul><li><div class="code-wrapper"><pre><code class="css">.container &#123;    flex-direction: row | row-reverse | column | column-reverse;&#125;<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs lua"><br>    -   默认为 row<br><br>-   改变折行<br><br>    -   ```css<br>        .container &#123;<br>            flex-<span class="hljs-built_in">wrap</span>: nowrap | <span class="hljs-built_in">wrap</span> | <span class="hljs-built_in">wrap</span>-<span class="hljs-built_in">reverse</span>;<br>        &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>默认为 no-wrap</p></li></ul></li><li><p>主轴对齐方式</p><ul><li><div class="code-wrapper"><pre><code class="CSS">.container &#123;  justify-content:flex-start | flex-end | center | space-between | space-around | space-evenly&#125;<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs coq"><br>    -   默认主轴为横轴（flex：row）<br><br>-   次轴对齐方式<br><br>    -   ```css<br>        .container &#123;<br>            allign-items: flex-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span> | <span class="hljs-type">baseline</span>;<br>        &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>默认为 stretch</p></li></ul></li><li><p>多行内容</p><ul><li><div class="code-wrapper"><pre><code class="css">.container &#123;    align-content: flex-start | flex-end;&#125;</code></pre></div></li></ul></li></ul></li><li><p>Item</p><ul><li><p>order</p><p>设置流动次序，会按照自然数排列</p></li><li><p>flex-grow</p><p>控制如何“长胖”，默认为 0</p></li><li><p>Flex-shrink</p><p>控制如何“变瘦”，<strong>默认为 1</strong>，一般设为 0 防止变瘦</p></li><li><p>flex-basis</p><p>控制基本宽度，默认为 auto，较少使用</p></li><li><p>flex</p><p>以上的缩写，格式为 flex:flex-grow flex-shrink flex-basis</p></li><li><p>Align-self</p><p>设置独立的对齐方式，填入值与 align-items 相同；</p></li></ul></li><li><p>一些其它技巧</p><ul><li>平均布局时还是要使用-margin 法解决被挤出去的问题</li><li>在一些情况下可以不使用 justify- content：space- between 进行，可以改用 margin：auto 的方法来，这个方法相对更加灵活一点。</li></ul></li></ul></li><li><p>grid 布局</p><p>一维布局用 flex，二维布局用 gird</p><p>grid 布局目前还在普及中，可以参考阮一峰的这篇教程：<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p></li><li><p>定位</p><p>布局是屏幕平面上的，定位是<strong>垂直于屏幕</strong>的</p><ul><li>position:<ul><li>Static 静态，是默认值</li><li>relative 相对定位，不脱离文档流</li><li>absolute 绝对定位，脱离文档流，相对于祖先元素中第一个 position 不是 static 的元素</li><li>fixed 固定定位，相对于视口定位（有问题，比如加了在此元素使用 transform 之后就不好使了），同时<strong>在移动端尽量不要用 fixed 属性</strong></li><li>sticky 粘滞定位，类似 V2ex 评论框</li></ul></li><li>index<ul><li><img src="/img/pic3.png" alt="pic3"></li></ul></li></ul></li><li><p><strong>层叠上下文</strong></p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context">层叠上下文 - CSS（层叠样式表） | MDN (mozilla.org)</a></p></li><li><p><img src="/img/pic4.png" alt="pic4"></p></li><li><p>简单记录几个目前遇到的会产生层叠上下文的条件</p><ul><li>根元素<html></li><li>position 为 absolute 或者 relative 且 z-index 不为 0</li><li>position 为 fixed 或者 sticky</li><li>flex 以及 grid 的子元素，且 index 不为 0</li><li>opacity 小于 1</li><li>设置有如下属性的元素<ul><li>filter</li><li>transform</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Html5基础总结</title>
    <link href="/2021/08/07/html5/"/>
    <url>/2021/08/07/html5/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5-讲义"><a href="#HTML5-讲义" class="headerlink" title="HTML5 讲义"></a>HTML5 讲义</h1><h2 id="章节标签"><a href="#章节标签" class="headerlink" title="章节标签"></a>章节标签</h2><ul><li>标题 h1~h6</li><li>章节 section</li><li>文章 article</li><li>段落 p</li><li>头部 header</li><li>脚部 footer</li><li>主要内容 main</li><li>旁枝内容 aside</li><li>划分 div</li></ul><h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><ul><li>class</li><li>Contenteditable 表示可以编辑</li><li>hidden</li><li>id</li><li>style</li><li>tabindex 表示可以用 tab 进行选择，tab 时会按照 index 递增顺序访问，0 为最后一个（不是第一个），-1 则为用 tab 永远无法访问</li><li>title</li></ul><h2 id="内容标签"><a href="#内容标签" class="headerlink" title="内容标签"></a>内容标签</h2><ul><li>ol + li</li><li>ul + li</li><li>dl + dt + dd</li><li>pre</li><li>hr</li><li>br</li><li>a</li><li>em</li><li>strong</li><li>code</li><li>quote</li><li>blockquote</li></ul><h2 id="HTML-重点标签"><a href="#HTML-重点标签" class="headerlink" title="HTML 重点标签"></a>HTML 重点标签</h2><ul><li><p>a 标签</p><ul><li>属性<ul><li>herf<ul><li>网址<ul><li><a href="http://www.google.com/">http://www.google.com</a></li><li><a href="https://www.google.com/">Https://www.google.com</a></li><li><strong>&#x2F;&#x2F;<a href="http://www.google.com/">www.google.com</a> 无协议打开,建议使用此方式</strong></li></ul></li><li>路径<ul><li><strong>a&#x2F;b&#x2F;c 开启服务器后注意此时根目录为开启服务的文件夹</strong></li></ul></li><li>伪协议<ul><li>javascript:代码 现在使用的主要是 javascripte:;</li><li>#id 跳转到指定 id 位置</li><li>mailto:邮箱</li><li>tel:手机号</li></ul></li></ul></li><li>target<ul><li>_blank</li><li>_self</li><li>_top 结合 iframe 理解</li><li>_parent 结合 ifame 理解</li></ul></li><li>download 理论上下载</li><li>rel&#x3D;noopener</li></ul></li><li>作用<ul><li>跳转外部页面</li><li>跳转到内部锚点</li><li>跳转到邮箱或者电话</li></ul></li></ul></li><li><p>table 标签</p><ul><li>样式<ul><li>table-layout</li><li>border-collapse</li><li>boder-spacing</li></ul></li></ul></li><li><p>img 标签 <strong>发出 get 请求，使用一张图片</strong></p><ul><li>属性<ul><li>src</li><li>alt</li><li>height 只写数字就可以</li><li>width 只写数字就可以</li></ul></li><li>事件<ul><li>onload</li><li>onerror</li></ul></li><li>响应式<ul><li>max-width&#x3D;100%</li></ul></li><li>img 是一个可替换元素，也就是说展现效果不由 css 控制，css 可以影响替换元素的位置，但是不能影响可替换元素本身的内容 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">可替换元素 MDN</a></li></ul></li><li><p>form 标签 <strong>发出 get 或者 post 请求，然后刷新页面</strong></p><ul><li>属性<ul><li>action</li><li>autocomplete</li><li>method</li><li>target</li></ul></li><li>事件<ul><li>onsubmit</li></ul></li><li>Input:submit 和 button 区别在于 button 可以包裹其他元素，而 input：submit 不能，另外一个 form 内必须有一个 submit 标签，只有一个 button 且该 button 没写 type 时那么这个 button 就会有 submit 的作用</li></ul></li><li><p>input 标签</p><ul><li>验证器</li></ul></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>安装 http-sever 来打开文件，<a href="https://www.jianshu.com/p/b9f043a2ba94">http-server 的安装和使用 - 简书 (jianshu.com)</a> http-server -c-1(简写 hs -c-1)无缓存打开</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git教程笔记</title>
    <link href="/2021/08/06/Git%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/06/Git%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-教程笔记"><a href="#Git-教程笔记" class="headerlink" title="Git 教程笔记"></a>Git 教程笔记</h1><h2 id="Git-的-6-条初始配置"><a href="#Git-的-6-条初始配置" class="headerlink" title="Git 的 6 条初始配置"></a>Git 的 6 条初始配置</h2><figure class="highlight sh"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs sh">git config --global user.name 你的英文名<br>git config --global user.email 你的邮箱<br>git config --global push.default simple<br>git config --global core.quotepath <span class="hljs-literal">false</span><br>git config --global core.editor <span class="hljs-string">&quot;code --wait&quot;</span><br>git config --global core.autocrlf input<br></code></pre></td></tr></table></figure><p>​ 分条解释及参考如下：</p><p><code>git config --global user.name</code>设置 name</p><p><code>git config --global user.email</code>设置 email</p><p><code>git config --global push.default simple</code> <a href="https://blog.csdn.net/wulove52/article/details/52357006">git config –global push.default simple 的相关解读_黑夜人的博客-CSDN 博客</a></p><p><code>git config --global core.quotepath false</code> <a href="https://www.cnblogs.com/perseus/archive/2012/11/21/2781074.html">git 乱码解决方案汇总 - 灵聚 - 博客园 (cnblogs.com)</a></p><p><code>git config --global core.editor &quot;code --wait&quot;</code> <a href="https://blog.csdn.net/zZzZzZ__/article/details/98769284">git config –global core.editor 的理解_只想整天学习-CSDN 博客</a></p><p><code>git config --global core.autocrlf input</code> <a href="https://blog.csdn.net/xuewuzhijin2012/article/details/50117181">git core.autocrlf 配置说明_xuewuzhijin2012 的专栏-CSDN 博客_core.autocrlf</a></p><p><strong>设置完毕之后可以使用<code>git config --global --list</code>查看设置情况</strong></p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p><code>git init</code> 初始化生成.git 目录</p><p><code>git add 路径</code> 标记那些变动是需要提交的，相对以及绝对路径均可，以及.和*</p><ul><li><p>当被跟踪的文件里面有不想跟踪的文件时，可以使用命令 git rm 删除文件或者跟踪，使用方法如下：</p><ul><li><p><code>git rm --cached readme1.txt </code> 删除 readme1.txt 的跟踪，并保留在本地。</p></li><li><p><code>git rm --f readme1.txt</code> 删除 readme1.txt 的跟踪，并且删除本地文件。</p></li></ul></li></ul><p>.gitignore 文件用于标记哪些变动是不需要提交的</p><p><code>git commit -m 字符串</code> 提交，字符串为理由，字符串里面如果有空格，最好用引号包起来</p><p><strong>另外一种更加推荐方式是<code>git commit -v</code> 可以添加更详细的信息</strong></p><p><code>git log</code> 只显示之前的提交</p><p><strong><code>git reflog</code> 可以显示所有的提交以及回退的操作</strong></p><p><code>git reset --hard XXXXXX</code> XXXXXX 是提交号的前六位，该指令可以回退版本，回退之前务必保证目前进度已经 commit</p><p><code>git branch xxx</code> 基于当前的 commit 创建一个新的分支</p><p><code>git checkout</code> 用于切换到另外一个分支</p><p><code>git merge</code> 合并分支，合并可能会出现冲突</p><ul><li>发现冲突<ul><li>冲突时会有 conflict 提示</li><li><strong>使用<code>git status -sb</code> 命令查看冲突出现的位置</strong></li></ul></li><li>解决冲突<ul><li>打开文件寻找&#x3D;&#x3D;&#x3D;&#x3D;，对比保留需要的文件</li><li>删除不用的代码，包括&#x3D;&#x3D;&#x3D; &gt;&gt;&gt; &lt;&lt;&lt;&lt;这些</li><li><strong>git add 再次添加对应文件</strong></li><li><strong>再次使用<code>git status -sb</code> 命令查看冲突出现的位置</strong></li><li>没有冲突之后直接使用<code>git commit</code> <strong>注意不需要选项</strong></li></ul></li></ul><p><code>git branch -d xxx</code> 该命令用于删除分支</p><h2 id="Github-远程操作"><a href="#Github-远程操作" class="headerlink" title="Github 远程操作"></a>Github 远程操作</h2><ul><li>结合官方文档设置 SSH</li><li>建立一个 repo</li><li><code>git remote add origin git@XXXX</code> 在本地仓库添加远程仓库地址，Origin 是远程仓库的默认名称，可以改但是没必要，自己的仓库使用 SSH 不使用 HTTP 会方便一点</li><li><code>git push -u origin master</code> 推送本地 maste 分支到远程 origin 的 master 分支，-u 只在初次设置时使用，以后可以直接使用<code>git push </code> <code>git pull</code></li><li>复制代码使用<code>git clone git@XXX.git</code><ul><li><img src="/img/pic1.png"></li></ul></li></ul><h2 id="使用-bash-alisa-简化命令"><a href="#使用-bash-alisa-简化命令" class="headerlink" title="使用 bash alisa 简化命令"></a>使用 bash alisa 简化命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias ga=&quot;git add&quot;&#x27;</span>&gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias gc=&quot;git commit -v&quot;&#x27;</span>&gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias gl=&quot;git pull&quot;&#x27;</span>&gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias gp=&quot;git push&quot;&#x27;</span>&gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias gco=&quot;git checkout&quot;&#x27;</span>&gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias gst=&quot;git status -sb&quot;&#x27;</span>&gt;&gt; ~/.bashrc<br><br></code></pre></td></tr></table></figure><p>最后 code ~&#x2F;.bashrc 在文件最后加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> glog=<span class="hljs-string">&quot;git log --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit -- | less&quot;</span><br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><h2 id="其他一些记录的问题"><a href="#其他一些记录的问题" class="headerlink" title="其他一些记录的问题"></a>其他一些记录的问题</h2><ul><li>ZSH 默认不显示 GIT 分支，安装 ohmyzsh 可解决，<a href="https://github.com/ohmyzsh/ohmyzsh/wiki">Home · ohmyzsh&#x2F;ohmyzsh Wiki (github.com)</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
